[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Utilizing historical maps in identification of long-term land use changes",
    "section": "",
    "text": "Published in Ambio: DOI: 10.1007/s13280-023-01838-z\n\nAbstract\n\nKnowledge in the magnitude and historical trends in land use and land cover (LULC) is needed to understand the changing status of the key elements of the landscape and to better target management efforts. However, this information is not easily available before the start of satellite campaign missions. Scanned historical maps are a valuable but underused source of LULC information. As a case study, we used U-Net to automatically extract fields, mires, roads, watercourses, and water bodies from scanned historical maps, dated 1965, 1984 and 1985 for our 900 km² study area in Southern Finland. We then used these data, along with the topographic databases from 2005 and 2022, to quantify the LULC changes for the past 57 years. For example, the total area of fields decreased by around 27 km², and the total length of watercourses increased by around 2250 km in our study area.\n\n\n\nData used\n\nThe study area is located in the vicinity of Evo, Finland, and consists of 9 map sheets, each covering an area of 10x10 km. From each map sheet, we have two different historical scanned maps, older from 1965 and newer from either 1984 or 1985. The maps were provided by National Land Survey of Finland, and the ground control points for each individual map were acquired from vanhatkartat.fi by Shingle Oy. Reference data from 2005 and 2022 is based on topographic database by NLS Finland, and it can be acquired for instance from Paituli download service.\n\n\nAuthors\n\nJanne Mäyrä, Finnish Environment Institute SYKE\nSonja Kivinen, University of Eastern Finland\nSarita Keski-Saari, University of Eastern Finland\nLaura Poikolainen, University of Eastern Finland\nTimo Kumpula, University of Eastern Finland\n\n\n\nAcknowledgments\nThe authors wish to acknowledge CSC – IT Center for Science, Finland, for computational resources.\nThis study was supported by the following projects:\n\nIBC-Carbon\nFinnish Ecosystem Observatory\nC-NEUT"
  },
  {
    "objectID": "crop_and_georeference.html",
    "href": "crop_and_georeference.html",
    "title": "Crop and georeference old maps",
    "section": "",
    "text": "Code\nimport pandas as pd\nfrom osgeo import gdal\nfrom pyproj import CRS, Transformer\nimport os\nfrom pathlib import Path\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport cv2\nimport numpy as np\n\n\n\n1 Study area and used map data\nThe study area is located in the vicinity of Evo, Finland, and consists of 9 map sheets. From each map sheet, we have two different historical scanned maps, older from 1965 and newer from either 1984 or 1985. The maps were provided by The National Land Survey of Finland, and the ground control points for each individual map were acquired from vanhatkartat.fi by Shingle Oy.\n\n\n2 Cropping\nAs the maps contain a lot of unnecessary information, such as ticks for coordinates and legend for map symbols, first step is to crop the maps to contain only the relevant information and adjust the GCPs accordingly.\n\n\nCode\nmap_path = Path('../data/maps/raw_maps/')\ngcp_path = Path('../data/gcps/raw/')\nmap_files = sorted([f for f in os.listdir(map_path) if f.endswith('jpg')])\n\n\nScanned old maps look like this:\n\n\nCode\nex_file = map_files[2]\nex_im = cv2.imread(str(map_path/ex_file))\nex_im = cv2.cvtColor(ex_im, cv2.COLOR_BGR2RGB)\nplt.imshow(ex_im)\nplt.title(ex_file)\nplt.show()\n\n\n\n\n\nAnd the corresponding ground control points (GCPs) are saved in this format:\n\n\nCode\npoints = pd.read_csv(gcp_path/f'{ex_file}.points')\npoints.head()\n\n\n\n\n\n\n  \n    \n      \n      mapX\n      mapY\n      pixelX\n      pixelY\n      enable\n      dX\n      dY\n      residual\n    \n  \n  \n    \n      0\n      24.929733\n      61.305223\n      574\n      700\n      1\n      0\n      0\n      0\n    \n    \n      1\n      25.116309\n      61.303818\n      6454\n      684\n      1\n      0\n      0\n      0\n    \n    \n      2\n      25.113131\n      61.214096\n      6470\n      6589\n      1\n      0\n      0\n      0\n    \n    \n      3\n      24.927086\n      61.215496\n      587\n      6607\n      1\n      0\n      0\n      0\n    \n  \n\n\n\n\nAt this point, we also adjust the white balance for all of the maps, as it varies a lot. As the reference white patch, we used 50x50 pixel patch outside the map contents.\n\n\nCode\nimport matplotlib.patches as patches\nfig, ax = plt.subplots(dpi=300)\nax.imshow(ex_im[int(points.iloc[3].pixelY-500):int(points.iloc[3].pixelY+500),\n                int(points.iloc[3].pixelX-500):int(points.iloc[3].pixelX+500)])\n\nrect = patches.Rectangle((250,250), 50,50, \n                         linewidth=1, edgecolor='r', facecolor='none')\nax.add_patch(rect)\nplt.show()\n\n\n\n\n\nTo visualize how much the color balance varies between sheets, the white reference patches look like this. Without any wear, each of these patches should be white.\n\n\nCode\npatches_65 = []\npatches_80s = []\nfor r in map_files:\n    m = cv2.imread(str(map_path/r))\n    points = pd.read_csv(gcp_path/f'{r}.points')\n    if '1965' in r:\n        patch = m[int(points.iloc[3].pixelY-250):int(points.iloc[3].pixelY-200), \n                  int(points.iloc[3].pixelX-250):int(points.iloc[3].pixelX-200)]\n        patches_65.append(patch)\n    else:\n        patch = m[int(points.iloc[3].pixelY-250):int(points.iloc[3].pixelY-200), \n                  int(points.iloc[3].pixelX-175):int(points.iloc[3].pixelX-125)]\n        patches_80s.append(patch)\n\nfig, axs = plt.subplots(3,3)\n\nfor p, a, fname in zip(patches_65, axs.flatten(), map_files[::2]):\n    a.set_xticks([])\n    a.set_yticks([])\n    a.imshow(cv2.cvtColor(p, cv2.COLOR_BGR2RGB))\n    a.set_title(fname[:-4])\n    \nplt.suptitle('White reference patches for maps from 1960s')\nplt.show()\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(3,3)\n\nfor p, a, fname in zip(patches_80s, axs.flatten(), map_files[1::2]):\n    a.set_xticks([])\n    a.set_yticks([])\n    a.imshow(cv2.cvtColor(p, cv2.COLOR_BGR2RGB))\n    a.set_title(fname[:-4])\n    \nplt.suptitle('White reference patches for maps from 1980s')\nplt.show()\n\npatches_80s = None\npatches_65 = None\n\n\n\n\n\nWhite balance is adjusted with the following formula, where ref_white is the mean value of the corresponding patch.\n\n\nCode\ndef white_balance(im, ref_white):\n    lum = sum(ref_white) / 3\n    r = im[...,2] * lum / ref_white[2]\n    g = im[...,1] * lum / ref_white[1]\n    b = im[...,0] * lum / ref_white[0]\n    r = np.clip(r, 0, 255).astype(np.uint8)\n    g = np.clip(g, 0, 255).astype(np.uint8)\n    b = np.clip(b, 0, 255).astype(np.uint8)\n    return np.dstack([b,g,r])\n\n\nNext step is to crop, scale GCPs and adjust white balance:\n\n\nCode\ncropped_gcp_path = Path('../data/gcps/cropped/')\ncropped_map_path = Path('../data/maps/cropped_maps/')\nfor m in map_files:\n    im = cv2.imread(str(map_path/m))\n    \n    points = pd.read_csv(gcp_path/f'{m}.points')\n    xmin = points.pixelX.min()\n    xmax = points.pixelX.max()\n    ymin = points.pixelY.min()\n    ymax = points.pixelY.max()\n    new_points = points.copy()\n    new_points.loc[0, 'pixelX'] = max(0, new_points.iloc[0]['pixelX'] - xmin)\n    new_points.loc[0, 'pixelY'] = max(0, new_points.iloc[0]['pixelY'] - ymin)\n    new_points.loc[1, 'pixelX'] = min(xmax-xmin, new_points.iloc[1]['pixelX']-xmin)\n    new_points.loc[1, 'pixelY'] = max(0, new_points.iloc[1]['pixelY'] - ymin)\n    new_points.loc[2, 'pixelX'] = min(xmax-xmin, new_points.iloc[2]['pixelX']-xmin)\n    new_points.loc[2, 'pixelY'] = min(ymax-ymin, new_points.iloc[2]['pixelY']-ymin)\n    new_points.loc[3, 'pixelX'] = max(0, new_points.iloc[3]['pixelX'] - xmin)\n    new_points.loc[3, 'pixelY'] = min(ymax-ymin, new_points.iloc[3]['pixelY']-ymin)\n    new_points.to_csv(cropped_gcp_path/f'{m}.points', index=False)\n    \n    if '1965' in r:\n        patch = im[int(points.iloc[3].pixelY-250):int(points.iloc[3].pixelY-200), \n                   int(points.iloc[3].pixelX-250):int(points.iloc[3].pixelX-200)]\n    else:\n        patch = im[int(points.iloc[3].pixelY-250):int(points.iloc[3].pixelY-200), \n                   int(points.iloc[3].pixelX-175):int(points.iloc[3].pixelX-125)]\n    \n    cropped_map = im[ymin:ymax, xmin:xmax]\n    cropped_map = white_balance(cropped_map, patch.mean(axis=(0,1)))\n    cv2.imwrite(str(cropped_map_path/m), cropped_map)\n\n\nAfter cropping only the relevant area remains, and all maps have more or less similar color balance.\n\n\nCode\ncropped_ex = cv2.imread(str(cropped_map_path/ex_file))\ncropped_ex = cv2.cvtColor(cropped_ex, cv2.COLOR_BGR2RGB)\nplt.imshow(cropped_ex)\nplt.title(ex_file)\nplt.show()\n\n\n\n\n\nAnd the GCPs are adjusted accordingly.\n\n\nCode\ncropped_points = pd.read_csv(cropped_gcp_path/f'{ex_file}.points')\ncropped_points.head()\n\n\n\n\n\n\n  \n    \n      \n      mapX\n      mapY\n      pixelX\n      pixelY\n      enable\n      dX\n      dY\n      residual\n    \n  \n  \n    \n      0\n      24.929733\n      61.305223\n      0\n      16\n      1\n      0\n      0\n      0\n    \n    \n      1\n      25.116309\n      61.303818\n      5880\n      0\n      1\n      0\n      0\n      0\n    \n    \n      2\n      25.113131\n      61.214096\n      5896\n      5905\n      1\n      0\n      0\n      0\n    \n    \n      3\n      24.927086\n      61.215496\n      13\n      5923\n      1\n      0\n      0\n      0\n    \n  \n\n\n\n\n\n\n3 Georeferencing\nAfter cropping, the maps are aligned and converted to EPSG:3067 coordinates, as it is closest to the original map CRS. GCPs are in EPSG:4326, so they need to be converted first. Overall it’s just a simple gdal.Translate and gdal.Warp.\n\n\nCode\naligned_map_outpath = Path('../data/maps/aligned_maps/')\n\nin_crs = CRS('EPSG:4326')\nout_crs = CRS('EPSG:3067')\ntransformer = Transformer.from_crs(in_crs, out_crs, always_xy=True)\n\nfor m in map_files:\n    gcp_list = []\n    new_points = pd.read_csv(cropped_gcp_path/f'{m}.points')\n    \n    for row in new_points.itertuples():\n        tfmd_x, tfmd_y = transformer.transform(row.mapX, row.mapY)\n        gcp_list.append(gdal.GCP(tfmd_x, tfmd_y, 1, row.pixelX, row.pixelY))\n        \n    translate_kwargs = {\n        'GCPs': gcp_list,\n        'format': 'GTIFF',\n        'bandList': [1,2,3]\n    }\n    \n    out_fname = m.replace('jpg', 'tif')\n    gdal.Translate(str(aligned_map_outpath/out_fname), str(cropped_map_path/m), **translate_kwargs)\n    gdal.Warp(str(aligned_map_outpath/out_fname), str(aligned_map_outpath/out_fname),\n              options='-r near -tps -co COMPRESS=LZW -t_srs EPSG:3067')\n\n\nFinal results are georeferenced RGB images in EPSG:3067 coordinates, which then look like this.\n\n\nCode\nimport rasterio as rio\nimport rasterio.plot as rioplot\n\n\n\n\nCode\nsrc = rio.open(aligned_map_outpath/ex_file.replace('jpg', 'tif'))\nrioplot.show(src)\n\n\n\n\n\n<AxesSubplot: >\n\n\nFinally a picture to show the full preprocessing workflow at once.\n\n\nCode\nfig, axs = plt.subplots(2,2, dpi=300, figsize=(12,12))\npoints = pd.read_csv(gcp_path/f'{ex_file}.points')\n\nfor a in axs.flatten()[:-1]: \n    a.set_xticks([])\n    a.set_yticks([])\naxs[0,0].imshow(ex_im)\naxs[0,1].imshow(ex_im[int(points.iloc[3].pixelY-500):int(points.iloc[3].pixelY+500),\n                      int(points.iloc[3].pixelX-500):int(points.iloc[3].pixelX+500)])\n\nrect = patches.Rectangle((250,250), 50,50, \n                         linewidth=1, edgecolor='r', facecolor='none')\naxs[0,1].add_patch(rect)\naxs[1,0].imshow(cropped_ex)\naxs[0,0].set_title('Raw scanned map sheet')\naxs[0,1].set_title('Location of reference patch for white balancing')\naxs[1,0].set_title('White balanced and cropped map')\naxs[1,1].set_title('Georeferenced map')\nrioplot.show(src, ax=axs[1,1])\nplt.savefig('../data/figures/preproc_steps.jpg', dpi=300, bbox_inches='tight')\nplt.show()"
  },
  {
    "objectID": "color_extraction.html",
    "href": "color_extraction.html",
    "title": "Extracting colors with simple thresholding",
    "section": "",
    "text": "The simplest approach for extracting information is a simple color extraction which can be used to detect land cover classes distinguished by color such as fields and waters. However, textural areas such as marshes can not be detected this way.\nAll these extractions are done with white-balance corrected images.\n\n\nCode\nimport cv2\nimport numpy as np\nimport os\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\n\n\n\n\nCode\ndatapath = Path('../data/maps/aligned_maps/')\nfiles = sorted(os.listdir(datapath))\nex_file = cv2.imread(str(datapath/files[3]))\nplt.imshow(cv2.cvtColor(ex_file, cv2.COLOR_BGR2RGB))\nplt.title(files[3])\n\n\nText(0.5, 1.0, '213406_1984.tif')\n\n\n\n\n\nFor easier color filtering, images are transformed into HSV colorspace\n\n\nCode\nhsv_ex = cv2.cvtColor(ex_file, cv2.COLOR_BGR2HSV)\nplt.imshow(hsv_ex)\nplt.title(files[4])\n\n\nText(0.5, 1.0, '213408_1965.tif')\n\n\n\n\n\n\n1 Fields\nHSV-range for fields is between [10, 100, 100] and [25, 255, 255]\n\n\nCode\nhsv_field_bot = np.array([10,100,100])\nhsv_field_top = np.array([25,255,255])\nfield_mask = cv2.inRange(hsv_ex, hsv_field_bot, hsv_field_top)\nfield_mask = field_mask.astype(np.int16)\nfig, axs = plt.subplots(1,2, figsize=(10,6), dpi=150)\nfield_mask[field_mask<128] = 0\nfield_mask[field_mask>128] = 1\naxs[0].imshow(field_mask, interpolation='none')\ntemp = ex_file.copy()\ntemp[field_mask == 0] = 255\naxs[1].imshow(cv2.cvtColor(temp, cv2.COLOR_BGR2RGB))\nplt.show()\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(1, 2, figsize=(10,6), dpi=150)\naxs[0].imshow(cv2.cvtColor(ex_file[500:1000, 4000:4500], cv2.COLOR_BGR2RGB))\naxs[1].imshow(cv2.cvtColor(temp[500:1000, 4000:4500], cv2.COLOR_BGR2RGB))\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\n\n\n2 Waters\nWater range is between [60,10,10] aand [130,255,255].\n\n\nCode\nhsv_water_bot = np.array([60,10,10])\nhsv_water_top = np.array([130,255,255])\nwater_mask = cv2.inRange(hsv_ex, hsv_water_bot, hsv_water_top)\nwater_mask = water_mask.astype(np.uint8)\nwater_mask = water_mask\nfig, axs = plt.subplots(1,2, figsize=(10,6), dpi=200)\nwater_mask[water_mask<128] = 0\nwater_mask[water_mask>128] = 1\naxs[0].imshow(water_mask, interpolation='none')\ntemp = ex_file.copy()\ntemp[water_mask == 0] = 255\naxs[1].imshow(cv2.cvtColor(temp, cv2.COLOR_BGR2RGB), interpolation='none')\nplt.show()\n\n\n\n\n\nThis approach, however, has some difficulties with ditches running through fields as their color is greenish rather than blue.\n\n\nCode\nfig, axs = plt.subplots(1, 2, figsize=(10,6), dpi=150)\naxs[0].imshow(cv2.cvtColor(ex_file[500:1000, 4000:4500], cv2.COLOR_BGR2RGB))\naxs[1].imshow(cv2.cvtColor(temp[500:1000, 4000:4500], cv2.COLOR_BGR2RGB))\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\nAlso, overlapping colors are fairly difficult situations.\n\n\nCode\nfig, axs = plt.subplots(1, 2, figsize=(10,6), dpi=150)\naxs[0].imshow(cv2.cvtColor(ex_file[500:1500, 2000:3000], cv2.COLOR_BGR2RGB))\naxs[1].imshow(cv2.cvtColor(temp[500:1500, 2000:3000], cv2.COLOR_BGR2RGB))\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\nDistinguishing between water bodies and waterways can be done fairly easily with MORPH_OPEN.\n\n\nCode\nwater_mask_open = cv2.morphologyEx(water_mask, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_RECT, (15,15)))\nfig, axs = plt.subplots(1, 3, dpi=200, figsize=(10,6))\naxs[0].imshow(water_mask[500:1500, 2000:3000])\naxs[0].set_title('Blue mask')\naxs[1].imshow(water_mask_open[500:1500, 2000:3000])\naxs[1].set_title('Water bodies')\naxs[2].imshow((water_mask - water_mask_open)[500:1500, 2000:3000])\naxs[2].set_title('Waterways')\n\n\nText(0.5, 1.0, 'Waterways')\n\n\n\n\n\nAfter some post-processing the waterway-layer looks fairly good.\n\n\nCode\nfrom skimage.morphology import skeletonize\n\nfig, axs = plt.subplots(1,3, dpi=200, figsize=(10,4))\nfor a in axs:\n    a.set_xticks([])\n    a.set_yticks([])\n\nwaterways = (water_mask - water_mask_open)[500:1500, 2000:3000]\naxs[0].imshow(waterways)\naxs[0].set_title('Waterways')\nopened = cv2.morphologyEx(waterways, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_CROSS, (5,5)))\naxs[1].imshow(opened)\naxs[1].set_title('Opening with 5x5 kernel')\naxs[2].imshow(skeletonize(opened))\naxs[2].set_title('Skeletonized waterways')\n\n\nText(0.5, 1.0, 'Skeletonized waterways')\n\n\n\n\n\n\n\n3 Roads\nAs red wraps around 180 in HSV-colorspace, two ranges are required for it.\n\n\nCode\nhsv_red_bot1 = np.array([0,10,10])\nhsv_red_top1 = np.array([5,255,255])\nhsv_red_bot2 = np.array([175,10,10])\nhsv_red_top2 = np.array([180,255,255])\nred_mask1 = cv2.inRange(hsv_ex, hsv_red_bot1, hsv_red_top1)\nred_mask1 = red_mask1.astype(np.int16)\nred_mask2 = cv2.inRange(hsv_ex, hsv_red_bot2, hsv_red_top2)\nred_mask2 = red_mask2.astype(np.int16)\nfig, axs = plt.subplots(1,2, figsize=(10,6), dpi=150)\nred_mask = red_mask1 | red_mask2\nred_mask[red_mask<128] = 0\nred_mask[red_mask>128] = 1\naxs[0].imshow(red_mask, interpolation='none')\ntemp = ex_file.copy()\ntemp[red_mask == 0] = 255\naxs[1].imshow(cv2.cvtColor(temp, cv2.COLOR_BGR2RGB))\nplt.show()\n\n\n\n\n\nAnother approach is to invert the RGB-image, convert it to HSV and look for cyan.\n\n\nCode\nplt.imshow(cv2.cvtColor(~ex_file, cv2.COLOR_BGR2RGB))\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\n\n\nCode\ninv_hsv = cv2.cvtColor(~ex_file, cv2.COLOR_BGR2HSV)\nhsv_cyan_bot = np.array([85,70,50])\nhsv_cyan_top = np.array([95,255,255])\ncyan_mask = cv2.inRange(inv_hsv, hsv_cyan_bot, hsv_cyan_top)\ncyan_mask = cyan_mask.astype(np.uint8)\nfig, axs = plt.subplots(1,2, figsize=(10,6), dpi=150)\ncyan_mask[cyan_mask<128] = 0\ncyan_mask[cyan_mask>128] = 1\naxs[0].imshow(cyan_mask, interpolation='none')\ntemp = ex_file.copy()\ntemp[cyan_mask == 0] = 255\naxs[1].imshow(cv2.cvtColor(temp, cv2.COLOR_BGR2RGB))\nplt.show()\n\n\n\n\n\nUnfortunately, there are lots of other things than roads that are red in the images. We can get rid of some of them with simple morphological opening but not nearly all of them.\n\n\nCode\nkernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))\nopened = cv2.morphologyEx(cyan_mask, cv2.MORPH_OPEN, kernel)\nplt.imshow(opened)\n\n\n<matplotlib.image.AxesImage>"
  },
  {
    "objectID": "make_masks.html",
    "href": "make_masks.html",
    "title": "Create reference masks",
    "section": "",
    "text": "Code\nfrom pathlib import Path\nimport os, sys\nimport cv2\nfrom PIL import Image\nimport matplotlib.pyplot as plt\nimport numpy as np"
  },
  {
    "objectID": "make_masks.html#section",
    "href": "make_masks.html#section",
    "title": "Create reference masks",
    "section": "1.1 1965",
    "text": "1.1 1965\n\n\nCode\nref_path = Path('../data/reference_masks')\nfields = cv2.imread(str(ref_path/'1965/fields.png'), cv2.IMREAD_UNCHANGED)\nwater_bodies = cv2.imread(str(ref_path/'1965/lakes.png'), cv2.IMREAD_UNCHANGED)\nrivers = cv2.imread(str(ref_path/'1965/rivers.png'), cv2.IMREAD_UNCHANGED)\nditches = cv2.imread(str(ref_path/'1965/ditches.png'), cv2.IMREAD_UNCHANGED)\nroads = cv2.imread(str(ref_path/'1965/roads.png'), cv2.IMREAD_UNCHANGED)\nmarshes = cv2.imread(str(ref_path/'1965/marshes.png'), cv2.IMREAD_UNCHANGED)\n\nwatercourses = ditches + rivers\n\nfig, axs = plt.subplots(2,3, figsize=(15,10), dpi=200)\nfor a in axs.flatten(): a.axis('off')\naxs[0,0].imshow(fields)\naxs[0,0].set_title('Fields and gardens')\naxs[0,1].imshow(roads)\naxs[0,1].set_title('Major roads')\naxs[0,2].set_title('Mires')\naxs[0,2].imshow(marshes)\naxs[1,0].imshow(ditches)\naxs[1,0].set_title('Ditches')\naxs[1,1].imshow(rivers)\naxs[1,1].set_title('Rivers')\naxs[1,2].imshow(water_bodies)\naxs[1,2].set_title('Water bodies')\n\nplt.show()\n\n\n\n\n\nStack these into a single image and save it.\n\n\nCode\noutim = np.empty((fields.shape), np.uint8)\noutim[fields > 0] = 1\noutim[marshes > 0] = 2\noutim[roads > 0] = 3\noutim[watercourses > 0] = 4\noutim[water_bodies > 0] = 5\nfig = plt.figure(figsize=(10,10), dpi=300)\nplt.imshow(outim, vmin=0, vmax=5, interpolation='none')\ncv2.imwrite(str(ref_path/'combined_mask_1965.png'), outim.astype('uint8'))\nplt.show()"
  },
  {
    "objectID": "make_masks.html#section-1",
    "href": "make_masks.html#section-1",
    "title": "Create reference masks",
    "section": "1.2 1984",
    "text": "1.2 1984\nDo the same for 1984.\n\n\nCode\nref_path = Path('../data/reference_masks')\nfields = cv2.imread(str(ref_path/'1984/fields.png'), cv2.IMREAD_UNCHANGED)\nwater_bodies = cv2.imread(str(ref_path/'1984/lakes.png'), cv2.IMREAD_UNCHANGED)\nrivers = cv2.imread(str(ref_path/'1984/rivers.png'), cv2.IMREAD_UNCHANGED)\nditches = cv2.imread(str(ref_path/'1984/ditches.png'), cv2.IMREAD_UNCHANGED)\nroads = cv2.imread(str(ref_path/'1984/roads.png'), cv2.IMREAD_UNCHANGED)\nmarshes = cv2.imread(str(ref_path/'1984/marshes.png'), cv2.IMREAD_UNCHANGED)\n\nwatercourses = ditches + rivers\n\nfig, axs = plt.subplots(2,3, figsize=(15,10), dpi=200)\nfor a in axs.flatten(): a.axis('off')\naxs[0,0].imshow(fields)\naxs[0,0].set_title('Fields and gardens')\naxs[0,1].imshow(roads)\naxs[0,1].set_title('Major roads')\naxs[0,2].set_title('Mires')\naxs[0,2].imshow(marshes)\naxs[1,0].imshow(ditches)\naxs[1,0].set_title('Ditches')\naxs[1,1].imshow(rivers)\naxs[1,1].set_title('Rivers')\naxs[1,2].imshow(water_bodies)\naxs[1,2].set_title('Water bodies')\n\nplt.show()\n\n\n\n\n\nStack these into a single mask.\n\n\nCode\noutim = np.empty((fields.shape), np.uint8)\noutim[fields > 0] = 1\noutim[marshes > 0] = 2\noutim[roads > 0] = 3\noutim[watercourses > 0] = 4\noutim[water_bodies > 0] = 5\nfig = plt.figure(figsize=(10,10), dpi=300)\nplt.imshow(outim, vmin=0, vmax=5, interpolation='none')\ncv2.imwrite(str(ref_path/'combined_mask_1984.png'), outim.astype('uint8'))\nplt.show()"
  },
  {
    "objectID": "make_masks.html#masks-side-by-side",
    "href": "make_masks.html#masks-side-by-side",
    "title": "Create reference masks",
    "section": "1.3 Masks side by side",
    "text": "1.3 Masks side by side\n\n\nCode\nfrom matplotlib import colors\ncmap = colors.ListedColormap(['white', 'tab:orange', 'tab:grey', 'tab:red', 'tab:cyan', 'tab:blue'])\nbounds=[0,1,2,3,4,5]\nnorm = colors.BoundaryNorm(bounds, cmap.N)\nmask_65 = cv2.imread(str(ref_path/'combined_mask_1965.png'),0)\nmask_84 = cv2.imread(str(ref_path/'combined_mask_1984.png'),0)\nfig, axs = plt.subplots(1,2, figsize=(10,6), dpi=300)\nfor a in axs: a.axis('off')\naxs[0].imshow(mask_65, vmin=0, vmax=5, cmap=cmap, interpolation='none')\naxs[0].set_title('1965')\naxs[1].imshow(mask_84, vmin=0, vmax=5, cmap=cmap, interpolation='none')\naxs[1].set_title('1984')\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "train_model.html",
    "href": "train_model.html",
    "title": "Train model",
    "section": "",
    "text": "from pathlib import Path\nimport os\nfrom fastai.vision.all import *\nfrom fastai.callback.wandb import *\nfrom fastai.callback.progress import ShowGraphCallback\nfrom fastai.callback.tracker import SaveModelCallback\nfrom drone_detector.engines.fastai.data import *\nfrom drone_detector.metrics import JaccardCoeffMulti\nimport wandb\n\nsys.path.append('..')\nfrom src.dataloaders import SegmentationDataLoadersFix\nfrom src.augmentations import RandomErasingSeg"
  },
  {
    "objectID": "train_model.html#example-result-patches",
    "href": "train_model.html#example-result-patches",
    "title": "Train model",
    "section": "2.1 Example result patches",
    "text": "2.1 Example result patches\n\nlearn = load_learner('../models/resnet152_focal_cutmasks.pkl', cpu=False)\nlearn.dls = dls\n\n\nvalid_im_path = Path('../data/processed/val/')\nval_images = [Path(valid_im_path/year/'raster_tiles'/f) for year in ['1965', '1984'] \n          for f in os.listdir(valid_im_path/year/'raster_tiles')]\n\n\ntestdl = learn.dls.test_dl(val_images, with_labels=True, bs=32, shuffle=True)\n\n\ntestdl.show_batch(max_n=8, cmap=cmap, alpha=0.8, vmin=0, vmax=5)\n\n\n\n\nCheck the loss, dice score and jaccard score for this dataset.\n\nlearn.validate(dl=testdl)\n\n\n\n\n\n\n\n\n(#3) [0.029747433960437775,0.9198446067228588,0.8382089817195901]\n\n\nAnd then some example results.\n\nlearn.show_results(dl=testdl, max_n=2, cmap=cmap, alpha=.95)\nf = plt.gcf()\nnorm = colors.Normalize(vmin=0,vmax=6)\nsm = plt.cm.ScalarMappable(cmap=cmap, norm=norm)\n#cbar = fig.colorbar(sm, ax=f.axes, ticks=np.arange(0.5,6.5), aspect=75)\n#cbar.ax.set_yticklabels(['Background', 'Fields', 'Mires', 'Roads', 'Watercourses', 'Water bodies'])\nplt.savefig('../data/figures/poster_preds.png', dpi=300, bbox_inches='tight')\nplt.tight_layout()"
  },
  {
    "objectID": "train_model.html#classwise-metrics",
    "href": "train_model.html#classwise-metrics",
    "title": "Train model",
    "section": "2.2 Classwise metrics",
    "text": "2.2 Classwise metrics\nThese results are before any morphological post-processings, and before merging the results into large tiles.\n\nfrom sklearn.metrics import precision_score, recall_score\n\ndef dice(targs, preds, cls_id):\n    inter = (torch.where(targs==cls_id, 1, 0)*torch.where(preds==cls_id, 1, 0)).float().sum()\n    union = (torch.where(targs==cls_id, 1, 0)+torch.where(preds==cls_id, 1, 0)).float().sum()\n    return 2 * inter/union if union > 0 else None\n\ndef jaccard(targs, preds, cls_id):\n    inter = (torch.where(targs==cls_id, 1, 0)*torch.where(preds==cls_id, 1, 0)).float().sum()\n    union = (torch.where(targs==cls_id, 1, 0)+torch.where(preds==cls_id, 1, 0)).float().sum()\n    return inter/(union-inter) if union > 0 else None\n\ndef pre(targs, preds, cls_id):\n    return precision_score(torch.where(targs==cls_id, 1, 0).flatten(), torch.where(preds==cls_id, 1, 0).flatten())\n    \ndef rec(targs, preds, cls_id):\n    return recall_score(torch.where(targs==cls_id, 1, 0).flatten(), torch.where(preds==cls_id, 1, 0).flatten())\n\n\n2.2.1 Validation set\n\n_,targs, preds = learn.get_preds(with_decoded=True)\n\n\n\n\n\n\n\n\n\n2.2.1.1 Fields\nDice score for fields:\n\ndice(targs, preds, 1)\n\nTensorBase(0.9731)\n\n\nJaccard score for fields:\n\njaccard(targs, preds, 1)\n\nTensorBase(0.9477)\n\n\nPrecision for fields:\n\npre(targs, preds, 1)\n\n0.972258257302713\n\n\nRecall for fields:\n\nrec(targs, preds, 1)\n\n0.9740398934335991\n\n\n\n\n2.2.1.2 Mires\nDice score for mires:\n\ndice(targs, preds, 2)\n\nTensorBase(0.8912)\n\n\nJaccard score for mires:\n\njaccard(targs, preds, 2)\n\nTensorBase(0.8037)\n\n\nPrecision for mires:\n\npre(targs, preds,2)\n\n0.884052339005425\n\n\nRecall for mires:\n\nrec(targs, preds, 2)\n\n0.8984412879455308\n\n\n\n\n2.2.1.3 Roads\nDice score for roads:\n\ndice(targs, preds, 3)\n\nTensorBase(0.8770)\n\n\nJaccard score for roads:\n\njaccard(targs, preds, 3)\n\nTensorBase(0.7809)\n\n\nPrecision for roads:\n\npre(targs, preds, 3)\n\n0.8530348089242903\n\n\nRecall for mires:\n\nrec(targs, preds, 3)\n\n0.90231700895208\n\n\n\n\n2.2.1.4 Watercourses\nDice score for watercourses:\n\ndice(targs, preds, 4)\n\nTensorBase(0.7721)\n\n\nJaccard score for watercourses:\n\njaccard(targs, preds, 4)\n\nTensorBase(0.6288)\n\n\nPrecision for watercourses:\n\npre(targs, preds, 4)\n\n0.7471939707544204\n\n\nRecall for watercourses\n\nrec(targs, preds, 4)\n\n0.7987637892901098\n\n\n\n\n2.2.1.5 Water bodies\nDice score for water bodies:\n\ndice(targs, preds, 5)\n\nTensorBase(0.9931)\n\n\nJaccard score for water bodies:\n\njaccard(targs, preds, 5)\n\nTensorBase(0.9863)\n\n\nPrecision for water bodies\n\npre(targs, preds, 5)\n\n0.9910614109293016\n\n\nRecall for water bodies:\n\nrec(targs, preds, 5)\n\n0.9951029661699824\n\n\n\n\n\n2.2.2 Test set\n\n_, targs, preds = learn.get_preds(dl=testdl, with_decoded=True)\n\n\n\n\n\n\n\n\n\n2.2.2.1 Fields\nDice score for fields:\n\ndice(targs, preds, 1)\n\nTensorBase(0.9697)\n\n\nJaccard score for fields:\n\njaccard(targs, preds, 1)\n\nTensorBase(0.9412)\n\n\nPrecision for fields:\n\npre(targs, preds, 1)\n\n0.9618274055387686\n\n\nRecall for fields:\n\nrec(targs, preds, 1)\n\n0.9777684946199127\n\n\n\n\n2.2.2.2 Mires\nDice score for mires:\n\ndice(targs, preds, 2)\n\nTensorBase(0.8981)\n\n\nJaccard score for mires:\n\njaccard(targs, preds, 2)\n\nTensorBase(0.8151)\n\n\nPrecision for mires:\n\npre(targs, preds,2)\n\n0.8723801784942353\n\n\nRecall for mires:\n\nrec(targs, preds, 2)\n\n0.9254702282614122\n\n\n\n\n2.2.2.3 Roads\nDice score for roads:\n\ndice(targs, preds, 3)\n\nTensorBase(0.8816)\n\n\nJaccard score for roads:\n\njaccard(targs, preds, 3)\n\nTensorBase(0.7882)\n\n\nPrecision for roads:\n\npre(targs, preds, 3)\n\n0.8464330652120925\n\n\nRecall for mires:\n\nrec(targs, preds, 3)\n\n0.9197872447043832\n\n\n\n\n2.2.2.4 Watercourses\nDice score for watercourses:\n\ndice(targs, preds, 4)\n\nTensorBase(0.8009)\n\n\nJaccard score for watercourses:\n\njaccard(targs, preds, 4)\n\nTensorBase(0.6679)\n\n\nPrecision for watercourses:\n\npre(targs, preds, 4)\n\n0.783207010142257\n\n\nRecall for watercourses\n\nrec(targs, preds, 4)\n\n0.8193276521039975\n\n\n\n\n2.2.2.5 Water bodies\nDice score for water bodies:\n\ndice(targs, preds, 5)\n\nTensorBase(0.9892)\n\n\nJaccard score for water bodies:\n\njaccard(targs, preds, 5)\n\nTensorBase(0.9786)\n\n\nPrecision for water bodies\n\npre(targs, preds, 5)\n\n0.9865743571649199\n\n\nRecall for water bodies:\n\nrec(targs, preds, 5)\n\n0.9917838442196202"
  },
  {
    "objectID": "postprocessings.html",
    "href": "postprocessings.html",
    "title": "Predictions and postprocessings",
    "section": "",
    "text": "We then used the model trained previously to classify all historical maps from our study area. In order to reduce noise and make predictions smoother, some post-processing steps are required. For this, we used morphological operations such as closing, and erosion, as well as low-pass filtering with suitable kernel sizes."
  },
  {
    "objectID": "postprocessings.html#fields",
    "href": "postprocessings.html#fields",
    "title": "Predictions and postprocessings",
    "section": "2.1 Fields",
    "text": "2.1 Fields\nComparison with automatically extracted orange color.\n\n\nCode\nhsv_field_bot = np.array([15,100,100])\nhsv_field_top = np.array([25,255,255])\ntempmap = mapdata[2500:3500, 2000:3000,:].copy()\n\nhsv_ex = cv2.cvtColor(tempmap, cv2.COLOR_RGB2HSV)\nfield_mask = cv2.inRange(hsv_ex, hsv_field_bot, hsv_field_top)\nfield_mask = field_mask.astype(np.int16)\n\nfig, axs = plt.subplots(2,2, figsize=(10,10), dpi=150)\n\nfor a in axs.flatten(): \n    a.set_xticks([])\n    a.set_yticks([])\n\nfield_mask[field_mask<128] = 0\nfield_mask[field_mask>128] = 1\naxs[0,0].imshow(field_mask, interpolation='none')\ntempmap = mapdata[2500:3500, 2000:3000,:].copy()\ntemp = tempmap.copy()\ntemp[field_mask == 0] = 255\naxs[0,1].imshow(temp, interpolation='none')\n\naxs[0,0].set_title('Automatical color extraxtion')\naxs[1,0].set_title('Unprocessed U-net results')\nfields = np.empty(data.shape)\nfields = fields.astype(np.uint8)\n\nfields[data==1] = 1\nfields = fields[2500:3500, 2000:3000]\naxs[1,0].imshow(fields, interpolation='none')\ntemp = tempmap.copy()\ntemp[fields == 0] = 255\naxs[1,1].imshow(temp, interpolation='none')\nplt.show()\n\n\n\n\n\nDuring postprocessing, include watercourses for these layers. MORPH.OPEN (erosion followed by dilation) with 11x11 kernel is sufficient to remove watercourses from non-field areas.\n\n\nCode\nfields = np.empty(data.shape)\nfields[data==1] = 1\nfields[data==4] = 1\nfields = fields[2500:3500, 2000:3000]\nfields = fields.astype(np.uint8)\nfig, axs = plt.subplots(1, 2, dpi=150)\ntempmap = mapdata[2500:3500, 2000:3000,:].copy()\ntempmap[fields != 1] = 255\naxs[0].imshow(fields)\naxs[1].imshow(tempmap)\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\nExample postprocessing chain looks like this.\n\n\nCode\nfig, axs = plt.subplots(5,2, dpi=200, figsize=(6,12))\nfor a in axs.flatten(): \n    a.set_xticks([])\n    a.set_yticks([])\n    \naxs[0,0].imshow(fields, interpolation='none')\naxs[0,0].set_title('Raw image')\naxs[0,1].set_title('Raw map')\naxs[0,1].imshow(tempmap, interpolation='none')\ner_kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (11,11))\ndil_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (11,11))\nopen_ex = cv2.erode(fields, er_kernel)\naxs[1,0].imshow(open_ex, interpolation='none')\naxs[1,0].set_title('Erosion with 11x11 kernel')\n\ntemp_open = mapdata[2500:3500, 2000:3000,:].copy()\ntemp_open[open_ex != 1] = 255\naxs[1,1].imshow(temp_open, interpolation='none')\n\nopen_ex = cv2.morphologyEx(open_ex, cv2.MORPH_OPEN, np.ones((3,3)))\nopen_ex = cv2.dilate(open_ex, dil_kernel)\naxs[2,0].imshow(open_ex, interpolation='none')\naxs[2,0].set_title('Dilation with 11x11 kernel')\n\ntemp_open = mapdata[2500:3500, 2000:3000,:].copy()\ntemp_open[open_ex != 1] = 255\naxs[2,1].imshow(temp_open, interpolation='none')\n\nlpf_kernel = np.ones((7,7), np.float32)/49\n\nlpf_ex = cv2.filter2D(open_ex, -1, lpf_kernel)\n\naxs[3,0].imshow(lpf_ex, interpolation='none')\naxs[3,0].set_title('Low-pass filter with 7x7 kernel')\n\ntemp_lpf = mapdata[2500:3500, 2000:3000,:].copy()\ntemp_lpf[lpf_ex != 1] = 255\n\naxs[3,1].imshow(temp_lpf, interpolation='none')\n\nroadclip = lpf_ex.copy()\nroadclip[data[2500:3500, 2000:3000] == 3] = 0\n\naxs[4,0].imshow(roadclip, interpolation='none')\naxs[4,0].set_title('Clipping with roads')\n\ntemp_lpf[data[2500:3500, 2000:3000] == 3] = 255\n\naxs[4,1].imshow(temp_lpf, interpolation='none')\n\nplt.savefig('../data/figures/field_postproc.jpg', dpi=300, bbox_inches='tight')\nplt.show()"
  },
  {
    "objectID": "postprocessings.html#mires",
    "href": "postprocessings.html#mires",
    "title": "Predictions and postprocessings",
    "section": "2.2 Mires",
    "text": "2.2 Mires\nSimilar to fields, watercourses running through mires do not split mires into multiple sections.\n\n\nCode\nmires = np.empty(data.shape)\nmires[data==2] = 1\nmires[data==4] = 1\nmires = mires[4000:6000, 2000:4000]\nmires = mires.astype(np.uint8)\nfig, axs = plt.subplots(1, 2, dpi=150)\ntempmap = mapdata[4000:6000, 2000:4000,:].copy()\ntempmap[mires != 1] = 0\naxs[0].imshow(mires)\naxs[1].imshow(tempmap)\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(4,2, dpi=200, figsize=(6,12))\nfor a in axs.flatten(): a.axis('off')\n    \naxs[0,0].imshow(mires, interpolation='none')\naxs[0,0].set_title('Raw image')\naxs[0,1].set_title('Raw map')\naxs[0,1].imshow(tempmap, interpolation='none')\ner_kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (13,13))\ndil_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (13,13))\nopen_ex = cv2.erode(mires, er_kernel)\nopen_ex = cv2.morphologyEx(open_ex, cv2.MORPH_OPEN, np.ones((3,3)))\nopen_ex = cv2.dilate(open_ex, dil_kernel)\naxs[1,0].imshow(open_ex, interpolation='none')\naxs[1,0].set_title('Opening with 11x11 kernel')\n\ntemp_open =  mapdata[4000:6000, 2000:4000,:].copy()\ntemp_open[open_ex == 0] = 0\n\naxs[1,1].imshow(temp_open, interpolation='none')\n\nlpf_kernel = np.ones((7,7), np.float32)/49\n\nlpf_ex = cv2.filter2D(open_ex, -1, lpf_kernel)\n\naxs[2,0].imshow(lpf_ex, interpolation='none')\naxs[2,0].set_title('Low-pass filter with 7x7 kernel')\n\ntemp_lpf =  mapdata[4000:6000, 2000:4000,:].copy()\ntemp_lpf[lpf_ex == 0] = 0\n\naxs[2,1].imshow(temp_lpf, interpolation='none')\n\nroadclip = lpf_ex.copy()\nroadclip[data[4000:6000, 2000:4000] == 3] = 0\n\naxs[3,0].imshow(roadclip, interpolation='none')\naxs[3,0].set_title('Clipping with roads')\n\ntemp_lpf[data[4000:6000, 2000:4000] == 3] = 255\n\naxs[3,1].imshow(temp_lpf, interpolation='none')\n\nplt.show()"
  },
  {
    "objectID": "postprocessings.html#roads",
    "href": "postprocessings.html#roads",
    "title": "Predictions and postprocessings",
    "section": "2.3 Roads",
    "text": "2.3 Roads\nRoads are postprocessed with MORPH.CLOSE (dilation followed by erosion), LPF and erosion.\n\n\nCode\nroads = np.empty(data.shape)\nroads[data==3] = 1\nroads = roads[300:1300, 4500:5500]\nroads = roads.astype(np.uint8)\nfig, axs = plt.subplots(1, 2, dpi=150)\ntempmap = mapdata[300:1300, 4500:5500,:].copy()\ntempmap[roads != 1] = 0\naxs[0].imshow(roads)\naxs[1].imshow(tempmap)\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(4,2, dpi=150, figsize=(8,16))\nfor a in axs.flatten(): a.axis('off')\n    \naxs[0,0].imshow(roads, interpolation='none')\naxs[0,0].set_title('Raw image')\naxs[0,1].set_title('Raw map')\naxs[0,1].imshow(tempmap)\n\nkernel = np.ones((7,7), np.uint8)\nopen_ex = cv2.morphologyEx(roads, cv2.MORPH_CLOSE, kernel)\ntemp_open = mapdata[300:1300, 4500:5500,:].copy()\ntemp_open[open_ex != 1] = 0\naxs[1,0].imshow(open_ex, interpolation='none')\naxs[1,0].set_title('Closing with 7x7 kernel')\naxs[1,1].imshow(temp_open, interpolation='none')\n\nlpf_kernel = np.ones((5,5), np.float32)/25\nlpf_ex = cv2.filter2D(open_ex, -1, lpf_kernel)\ntemp_lpf = temp_open.copy()\ntemp_lpf[lpf_ex == 0] = 0\naxs[2,0].imshow(lpf_ex, interpolation='none')\naxs[2,0].set_title('Low-pass filter with 5x5 kernel')\naxs[2,1].imshow(temp_lpf, interpolation='none')\n\neroded = cv2.erode(lpf_ex, np.ones((3,3), np.uint8), iterations=1)\ntemp_er = mapdata[300:1300, 4500:5500,:].copy()\ntemp_er[eroded != 1] = 0\naxs[3,0].imshow(eroded, interpolation='none')\naxs[3,0].set_title('Erosion with 3x3 kernel')\naxs[3,1].imshow(temp_er, interpolation='none')\n\nplt.show()\n\n\n\n\n\nNext step is to skeletonize roads in order to generate line geometries from them.\n\n\nCode\nskeletonized = skeletonize(eroded)\n\nfig, axs = plt.subplots(1,2, figsize=(10,5), dpi=300)\nfor a in axs: a.axis('off')\n\naxs[0].imshow(eroded, interpolation='none')\naxs[1].imshow(skeletonized, interpolation='none')\nplt.show()\n\n\n\n\n\nThese are then polygonized and merged into polygon data, that can then be used to get line geometries."
  },
  {
    "objectID": "postprocessings.html#watercourses",
    "href": "postprocessings.html#watercourses",
    "title": "Predictions and postprocessings",
    "section": "2.4 Watercourses",
    "text": "2.4 Watercourses\n\n\nCode\nwatercourses = np.empty(data.shape)\nwatercourses[data==4] = 1\nwatercourses = watercourses[2500:3500,2000:3000]\nwatercourses = watercourses.astype(np.uint8)\nfig, axs = plt.subplots(1, 2, dpi=150)\ntempmap = mapdata[2500:3500, 2000:3000,:].copy()\ntempmap[watercourses != 1] = 0\naxs[0].imshow(watercourses)\naxs[1].imshow(tempmap)\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(4,2, dpi=150, figsize=(8,16))\nfor a in axs.flatten(): a.axis('off')\n    \naxs[0,0].imshow(watercourses, interpolation='none')\naxs[0,0].set_title('Raw image')\naxs[0,1].set_title('Raw map')\naxs[0,1].imshow(tempmap)\n\nkernel = np.ones((7,7), np.uint8)\nopen_ex = cv2.morphologyEx(watercourses, cv2.MORPH_CLOSE, kernel)\ntemp_open = tempmap.copy()\ntemp_open[open_ex != 1] = 0\naxs[1,0].imshow(open_ex, interpolation='none')\naxs[1,0].set_title('Closing with 7x7 kernel')\naxs[1,1].imshow(temp_open, interpolation='none')\n\nlpf_kernel = np.ones((5,5), np.float32)/25\nlpf_ex = cv2.filter2D(open_ex, -1, lpf_kernel)\ntemp_lpf =  mapdata[2500:3500, 2000:3000,:].copy()\ntemp_lpf[lpf_ex == 0] = 0\naxs[2,0].imshow(lpf_ex, interpolation='none')\naxs[2,0].set_title('Low-pass filter with 5x5 kernel')\naxs[2,1].imshow(temp_lpf, interpolation='none')\n\neroded = cv2.erode(lpf_ex, np.ones((3,3), np.uint8), iterations=1)\ntemp_er = mapdata[2500:3500, 2000:3000,:].copy()\ntemp_er[eroded != 1] = 0\naxs[3,0].imshow(eroded, interpolation='none')\naxs[3,0].set_title('Erosion with 3x3 kernel')\naxs[3,1].imshow(temp_er, interpolation='none')\n\nplt.show()\n\n\n\n\n\nVisually compare the different skeletonizing methods: skimage.morphology.skeletonize, skimage.morphology.thin and skimage.morphology.medial_axis.\n\n\nCode\nskeletonized = skeletonize(eroded[350:-350, 350:-350])\nthinned = thin(eroded[350:-350, 350:-350])\nmed_axis = medial_axis(eroded[350:-350, 350:-350])\n\nfig, axs = plt.subplots(2,2, figsize=(12,12), dpi=200)\nfor a in axs.flatten(): a.axis('off')\n\naxs[0,0].imshow(eroded[350:-350, 350:-350], interpolation='none')\naxs[0,0].set_title('Original')\naxs[0,1].imshow(skeletonized, interpolation='none')\naxs[0,1].set_title('Skeletonized')\naxs[1,0].imshow(thinned, interpolation='none')\naxs[1,0].set_title('Thinned')\naxs[1,1].imshow(med_axis, interpolation='none')\naxs[1,1].set_title('Medial axis')\nplt.show()\n\n\n\n\n\nSeems that no major differences between the methods,"
  },
  {
    "objectID": "postprocessings.html#water-bodies",
    "href": "postprocessings.html#water-bodies",
    "title": "Predictions and postprocessings",
    "section": "2.5 Water bodies",
    "text": "2.5 Water bodies\n\n\nCode\nwaterbodies = np.empty(data.shape)\nwaterbodies[data==5] = 1\nwaterbodies = waterbodies[1500:2500, 1000:2000]\nwaterbodies = waterbodies.astype(np.uint8)\nfig, axs = plt.subplots(1, 2, dpi=150)\ntempmap = mapdata[1500:2500, 1000:2000,:].copy()\ntempmap[waterbodies != 1] = 0\naxs[0].imshow(waterbodies)\naxs[1].imshow(tempmap)\n\n\n<matplotlib.image.AxesImage>\n\n\n\n\n\n\n\nCode\nfig, axs = plt.subplots(3,2, dpi=300, figsize=(8,12))\nfor a in axs.flatten(): a.axis('off')\n    \naxs[0,0].imshow(waterbodies, interpolation='none')\naxs[0,0].set_title('Raw image')\naxs[0,1].set_title('Raw map')\naxs[0,1].imshow(tempmap, interpolation='none')\nkernel = np.ones((11,11), np.uint8)\nopen_ex = cv2.morphologyEx(waterbodies, cv2.MORPH_OPEN, kernel)\naxs[1,0].imshow(open_ex, interpolation='none')\naxs[1,0].set_title('Opening with 11x11 kernel')\n\ntemp_open = mapdata[1500:2500, 1000:2000,:].copy()\ntemp_open[open_ex == 0] = 0\n\naxs[1,1].imshow(temp_open, interpolation='none')\n\nlpf_kernel = np.ones((7,7), np.float32)/49\n\nlpf_ex = cv2.filter2D(open_ex, -1, lpf_kernel)\n\naxs[2,0].imshow(lpf_ex, interpolation='none')\naxs[2,0].set_title('Low-pass filter with 9x9 kernel')\n\ntemp_lpf = mapdata[1500:2500, 1000:2000,:].copy()\ntemp_lpf[lpf_ex == 0] = 0\n\naxs[2,1].imshow(temp_lpf, interpolation='none')\n\nplt.show()"
  },
  {
    "objectID": "postprocessings.html#all-together",
    "href": "postprocessings.html#all-together",
    "title": "Predictions and postprocessings",
    "section": "2.6 All together:",
    "text": "2.6 All together:\n\n\nCode\ndef run_postproc_chain(inpath, outpath):\n    with rio.open(inpath) as src:\n        data = src.read()[0]\n        prof = src.profile\n    fields = np.where((data==1) | (data==4), 1, 0).astype(np.uint8)\n    mires = np.where((data==2) | (data==4), 1, 0).astype(np.uint8)\n    roads = np.where(data==3, 1, 0).astype(np.uint8)\n    watercourses = np.where(data==4, 1, 0).astype(np.uint8)\n    waterbodies = np.where(data==5, 1, 0).astype(np.uint8)\n    \n    er_kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (11,11))\n    dil_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (11,11))\n    \n    fields = cv2.erode(fields, er_kernel)\n    fields = cv2.morphologyEx(fields, cv2.MORPH_OPEN, np.ones((3,3)))\n    fields = cv2.dilate(fields, dil_kernel)\n    fields = cv2.filter2D(fields, -1,  np.ones((7,7), np.float32)/49)\n\n    mires = cv2.erode(mires, er_kernel)\n    mires = cv2.morphologyEx(mires, cv2.MORPH_OPEN, np.ones((3,3)))\n    mires = cv2.dilate(mires, dil_kernel)    \n    mires = cv2.filter2D(mires, -1,  np.ones((7,7), np.float32)/49)\n    \n    roads = cv2.morphologyEx(roads, cv2.MORPH_CLOSE, np.ones((7,7), np.uint8))\n    roads = cv2.filter2D(roads, -1, np.ones((5,5), np.float32)/25)\n\n    watercourses = cv2.morphologyEx(watercourses, cv2.MORPH_CLOSE, np.ones((7,7), np.uint8))\n    watercourses = cv2.filter2D(watercourses, -1, np.ones((5,5), np.float32)/25)\n    \n    waterbodies = cv2.morphologyEx(waterbodies, cv2.MORPH_OPEN, np.ones((11,11), np.uint8))\n    waterbodies = cv2.filter2D(waterbodies, -1,  np.ones((7,7), np.float32)/49)\n    \n    prof.update({'count': 5})\n    \n    # Roads split these classes into multiple geometries\n    fields[roads == 1] = 0\n    mires[roads == 1] = 0\n    # Clip with waterbodies also\n    fields[waterbodies == 1] = 0\n    mires[waterbodies == 1] = 0\n    \n    with rio.open(outpath, 'w', **prof) as dest:\n        dest.write(fields, 1)\n        dest.write(mires, 2)\n        dest.write(roads, 3)\n        dest.write(watercourses, 4)\n        dest.write(waterbodies, 5)\n\n\n\n\nCode\nfrom tqdm import tqdm\nfrom pathlib import Path\nimport os\n\nindir = Path('../results/raw/')\noutdir = Path('../results/processed/')\nfor f in tqdm(os.listdir(indir)):\n    run_postproc_chain(indir/f, outdir/f)\n\nval_indir = Path('../data/reference_masks/')\nval_outdir = Path('../data/reference_masks/postproc')\nfor f in tqdm(['val_mask_1965.tif', 'val_mask_1984.tif']):\n    run_postproc_chain(val_indir/f, val_outdir/f)\n\n\n100%|██████████████████████████████████████████████████████████████████████████████████| 18/18 [01:23<00:00,  4.64s/it]\n100%|████████████████████████████████████████████████████████████████████████████████████| 2/2 [00:03<00:00,  1.60s/it]"
  },
  {
    "objectID": "postprocessings.html#roads-1",
    "href": "postprocessings.html#roads-1",
    "title": "Predictions and postprocessings",
    "section": "4.1 Roads",
    "text": "4.1 Roads\nSkeletonizing.\n\n\nCode\nfig, axs = plt.subplots(1,2, figsize=(10,5), dpi=300)\naxs[0].imshow(road_data, cmap='binary')\naxs[0].set_title('Processed rasters')\naxs[1].imshow(skeletonize(cv2.erode(road_data, np.ones((3,3), np.uint8), iterations=1)), cmap='binary')\nplt.show()\n\n\n\n\n\nThen data are converted to polygons, buffered and merged, and centerline.geometry.Centerline is used to get line geometries from the data.\n\n\nCode\npolys = gpd.read_file('../results/polygons/roads/213411_1965.geojson')\nlines = gpd.read_file('../results/lines/roads/213411_1965.geojson')\nlines.plot()\n\n\n<AxesSubplot: >\n\n\n\n\n\nAs there were still some faulty locations (remnants from red numbers, for instance), we removed all line segments that were less than 100 meters long.\n\n\nCode\nlines[lines.length > 100].plot()\n\n\n<AxesSubplot: >"
  },
  {
    "objectID": "postprocessings.html#watercourses-1",
    "href": "postprocessings.html#watercourses-1",
    "title": "Predictions and postprocessings",
    "section": "4.2 Watercourses",
    "text": "4.2 Watercourses\nSkeletonizing\n\n\nCode\nfig, axs = plt.subplots(1,2, figsize=(10,5), dpi=300)\naxs[0].imshow(ww_data, cmap='binary')\naxs[0].set_title('Processed rasters')\naxs[1].imshow(skeletonize(cv2.erode(ww_data, np.ones((3,3), np.uint8), iterations=1)), cmap='binary')\nplt.show()\n\n\n\n\n\n\n\nCode\npolys = gpd.read_file('../results/polygons/watercourses/213411_1965.geojson')\nlines = gpd.read_file('../results/lines/watercourses/213411_1965.geojson')\nlines.plot()\n\n\n<AxesSubplot: >"
  },
  {
    "objectID": "postprocessings.html#fields-1",
    "href": "postprocessings.html#fields-1",
    "title": "Predictions and postprocessings",
    "section": "5.1 Fields",
    "text": "5.1 Fields\n\n\nCode\nfor r in ['213405_1965.tif', '213405_1984.tif']:\n    polygonize(respath/r, polypath/'fields'/r.replace('tif', 'geojson'), target_class=1, scale_factor=1/2)\n\nfor r in ['val_mask_1965.tif', 'val_mask_1984.tif']:\n    polygonize(refpath/'postproc'/r, refpath/'polydata/fields'/r.replace('tif', 'geojson'), target_class=1, scale_factor=1/2)\n\n\n\n\nCode\nfig, axs = plt.subplots(1,4, figsize=(8,4), dpi=200)\n\nfor a in axs: \n    a.set_xticks([])\n    a.set_yticks([])\n\npred_fields_65 = gpd.read_file(polypath/'fields/213405_1965.geojson')\nref_fields_65 = gpd.read_file(refpath/'polydata/fields/val_mask_1965.geojson')\npred_fields_65 = pred_fields_65.clip(box(*ref_fields_65.total_bounds))\npred_fields_65.plot(ax=axs[0]).set_title('Predicted 1965')\nref_fields_65 = ref_fields_65.clip(box(*pred_fields_65.total_bounds))\nref_fields_65.plot(ax=axs[1]).set_title('Annotated 1965')\npred_fields_84 = gpd.read_file(polypath/'fields/213405_1984.geojson')\nref_fields_84 = gpd.read_file(refpath/'polydata/fields/val_mask_1984.geojson')\npred_fields_84 = pred_fields_84.clip(box(*ref_fields_84.total_bounds))\npred_fields_84.plot(ax=axs[2]).set_title('Predicted 1984')\nref_fields_84 = ref_fields_84.clip(box(*pred_fields_84.total_bounds))\nref_fields_84.plot(ax=axs[3]).set_title('Annotated 1984')\n\nplt.tight_layout()\n\n\n\n\n\n\n\nCode\nprint(f'Total predicted field area in 1965: {pred_fields_65.area.sum()*10**-6:.3f} km²')\nprint(f'Total annotated field area in 1965: {ref_fields_65.area.sum()*10**-6:.3f} km²')\nprint(f'Difference in km²: {(pred_fields_65.area.sum()*10**-6 - ref_fields_65.area.sum()*10**-6):.3f} km²')\nprint(f'%-difference: {100*(pred_fields_65.area.sum()*10**-6 - ref_fields_65.area.sum()*10**-6)/(ref_fields_65.area.sum()*10**-6):.3f} %')\n\n\nTotal predicted field area in 1965: 2.072 km²\nTotal annotated field area in 1965: 2.102 km²\nDifference in km²: -0.030 km²\n%-difference: -1.409 %\n\n\n\n\nCode\nprint(f'Total predicted field area in 1984: {pred_fields_84.area.sum()*10**-6:.3f} km²')\nprint(f'Total annotated field area in 1984: {ref_fields_84.area.sum()*10**-6:.3f} km²')\nprint(f'Difference in km²: {(pred_fields_84.area.sum()*10**-6 - ref_fields_84.area.sum()*10**-6):.3f} km²')\nprint(f'%-difference: {100*(pred_fields_84.area.sum()*10**-6 - ref_fields_84.area.sum()*10**-6)/(ref_fields_84.area.sum()*10**-6):.3f} %')\n\n\nTotal predicted field area in 1984: 1.749 km²\nTotal annotated field area in 1984: 1.769 km²\nDifference in km²: -0.020 km²\n%-difference: -1.120 %"
  },
  {
    "objectID": "postprocessings.html#mires-1",
    "href": "postprocessings.html#mires-1",
    "title": "Predictions and postprocessings",
    "section": "5.2 Mires",
    "text": "5.2 Mires\n\n\nCode\nfor r in ['213405_1965.tif', '213405_1984.tif']:\n    polygonize(respath/r, polypath/'mires'/r.replace('tif', 'geojson'), target_class=2, scale_factor=1/2)\n\nfor r in ['val_mask_1965.tif', 'val_mask_1984.tif']:\n    polygonize(refpath/'postproc'/r, refpath/'polydata/mires'/r.replace('tif', 'geojson'), target_class=2, scale_factor=1/2)\n\n\n\n\nCode\nfig, axs = plt.subplots(1,4, figsize=(8,4), dpi=200)\n\nfor a in axs: \n    a.set_xticks([])\n    a.set_yticks([])\n\npred_mires_65 = gpd.read_file(polypath/'mires/213405_1965.geojson')\nref_mires_65 = gpd.read_file(refpath/'polydata/mires/val_mask_1965.geojson')\npred_mires_65 = pred_mires_65.clip(box(*ref_mires_65.total_bounds))\npred_mires_65.plot(ax=axs[0]).set_title('Predicted 1965')\nref_mires_65 = ref_mires_65.clip(box(*pred_mires_65.total_bounds))\nref_mires_65.plot(ax=axs[1]).set_title('Annotated 1965')\npred_mires_84 = gpd.read_file(polypath/'mires/213405_1984.geojson')\nref_mires_84 = gpd.read_file(refpath/'polydata/mires/val_mask_1984.geojson')\npred_mires_84 = pred_mires_84.clip(box(*ref_mires_84.total_bounds))\npred_mires_84.plot(ax=axs[2]).set_title('Predicted 1984')\nref_mires_84 = ref_mires_84.clip(box(*pred_mires_84.total_bounds))\nref_mires_84.plot(ax=axs[3]).set_title('Annotated 1984')\n\nplt.tight_layout()\n\n\n\n\n\n\n\nCode\nprint(f'Total predicted mire area in 1965: {pred_mires_65.area.sum()*10**-6:.3f} km²')\nprint(f'Total annotated mire area in 1965: {ref_mires_65.area.sum()*10**-6:.3f} km²')\nprint(f'Difference in km²: {(pred_mires_65.area.sum()*10**-6 - ref_mires_65.area.sum()*10**-6):.3f} km²')\nprint(f'%-difference: {100*(pred_mires_65.area.sum()*10**-6 - ref_mires_65.area.sum()*10**-6)/(ref_mires_65.area.sum()*10**-6):.3f} %')\n\n\nTotal predicted mire area in 1965: 5.789 km²\nTotal annotated mire area in 1965: 5.919 km²\nDifference in km²: -0.129 km²\n%-difference: -2.182 %\n\n\n\n\nCode\nprint(f'Total predicted mire area in 1984: {pred_mires_84.area.sum()*10**-6:.3f} km²')\nprint(f'Total annotated mire area in 1984: {ref_mires_84.area.sum()*10**-6:.3f} km²')\nprint(f'Difference in km²: {(pred_mires_84.area.sum()*10**-6 - ref_mires_84.area.sum()*10**-6):.3f} km²')\nprint(f'%-difference: {100*(pred_mires_84.area.sum()*10**-6 - ref_mires_84.area.sum()*10**-6)/(ref_mires_84.area.sum()*10**-6):.3f} %')\n\n\nTotal predicted mire area in 1984: 5.804 km²\nTotal annotated mire area in 1984: 6.001 km²\nDifference in km²: -0.196 km²\n%-difference: -3.270 %"
  },
  {
    "objectID": "postprocessings.html#roads-2",
    "href": "postprocessings.html#roads-2",
    "title": "Predictions and postprocessings",
    "section": "5.3 Roads",
    "text": "5.3 Roads\n\n\nCode\nfig, axs = plt.subplots(1,4, figsize=(8,4), dpi=200)\n\nfor a in axs: \n    a.set_xticks([])\n    a.set_yticks([])\n\npred_roads_65 = gpd.read_file(linepath/'roads/213405_1965.geojson')\nref_roads_65 = gpd.read_file(ref_linepath/'roads/val_mask_1965.geojson')\npred_roads_65 = pred_roads_65.clip(box(*ref_roads_65.total_bounds))\npred_roads_65.plot(ax=axs[0]).set_title('Predicted 1965')\nref_roads_65 = ref_roads_65.clip(box(*pred_roads_65.total_bounds))\nref_roads_65.plot(ax=axs[1]).set_title('Annotated 1965')\npred_roads_84 = gpd.read_file(linepath/'roads/213405_1984.geojson')\nref_roads_84 = gpd.read_file(ref_linepath/'roads/val_mask_1984.geojson')\npred_roads_84 = pred_roads_84.clip(box(*ref_roads_84.total_bounds))\npred_roads_84.plot(ax=axs[2]).set_title('Predicted 1984')\nref_roads_84 = ref_roads_84.clip(box(*pred_roads_84.total_bounds))\nref_roads_84.plot(ax=axs[3]).set_title('Annotated 1984')\n\nplt.tight_layout()\n\n\n\n\n\n\n\nCode\nprint(f'Total predicted road length in 1965: {pred_roads_65.length.sum()*10**-3:.3f} km')\nprint(f'Total annotated road length in 1965: {ref_roads_65.length.sum()*10**-3:.3f} km')\nprint(f'Difference in km: {(pred_roads_65.length.sum()*10**-3 - ref_roads_65.length.sum()*10**-3):.3f} km')\nprint(f'%-difference: {100*(pred_roads_65.length.sum()*10**-3 - ref_roads_65.length.sum()*10**-3)/(ref_roads_65.length.sum()*10**-3):.3f} %')\n\n\nTotal predicted road length in 1965: 15.759 km\nTotal annotated road length in 1965: 15.612 km\nDifference in km: -0.147 km\n%-difference: -0.943 %\n\n\n\n\nCode\nprint(f'Total predicted road length in 1984: {pred_roads_84.length.sum()*10**-3:.3f} km')\nprint(f'Total annotated road length in 1984: {ref_roads_84.length.sum()*10**-3:.3f} km')\nprint(f'Difference in km: {(ref_roads_84.length.sum()*10**-3 - pred_roads_84.length.sum()*10**-3):.3f} km')\nprint(f'%-difference: {100*(ref_roads_84.length.sum()*10**-3 - pred_roads_84.length.sum()*10**-3)/(ref_roads_84.length.sum()*10**-3):.3f} %')\n\n\nTotal predicted road length in 1984: 16.832 km\nTotal annotated road length in 1984: 16.200 km\nDifference in km: -0.632 km\n%-difference: -3.900 %"
  },
  {
    "objectID": "postprocessings.html#watercourses-2",
    "href": "postprocessings.html#watercourses-2",
    "title": "Predictions and postprocessings",
    "section": "5.4 Watercourses",
    "text": "5.4 Watercourses\n\n\nCode\nfig, axs = plt.subplots(1,4, figsize=(8,4), dpi=200)\n\nfor a in axs: \n    a.set_xticks([])\n    a.set_yticks([])\n\npred_watercourses_65 = gpd.read_file(linepath/'watercourses/213405_1965.geojson')\nref_watercourses_65 = gpd.read_file(ref_linepath/'watercourses/val_mask_1965.geojson')\npred_watercourses_65 = pred_watercourses_65.clip(box(*ref_watercourses_65.total_bounds))\npred_watercourses_65.plot(ax=axs[0]).set_title('Predicted 1965')\nref_watercourses_65 = ref_watercourses_65.clip(box(*pred_watercourses_65.total_bounds))\nref_watercourses_65.plot(ax=axs[1]).set_title('Annotated 1965')\npred_watercourses_84 = gpd.read_file(linepath/'watercourses/213405_1984.geojson')\nref_watercourses_84 = gpd.read_file(ref_linepath/'watercourses/val_mask_1984.geojson')\npred_watercourses_84 = pred_watercourses_84.clip(box(*ref_watercourses_84.total_bounds))\npred_watercourses_84.plot(ax=axs[2]).set_title('Predicted 1984')\nref_watercourses_84 = ref_watercourses_84.clip(box(*pred_watercourses_84.total_bounds))\nref_watercourses_84.plot(ax=axs[3]).set_title('Annotated 1984')\n\nplt.tight_layout()\n\n\n\n\n\n\n\nCode\nprint(f'Total predicted watercourse length in 1965: {pred_watercourses_65.length.sum()*10**-3:.3f} km')\nprint(f'Total annotated watercourse length in 1965: {ref_watercourses_65.length.sum()*10**-3:.3f} km')\nprint(f'Difference in km: {(ref_watercourses_65.length.sum()*10**-3 - pred_watercourses_65.length.sum()*10**-3):.3f} km')\nprint(f'%-difference: {100*(ref_watercourses_65.length.sum()*10**-3 - pred_watercourses_65.length.sum()*10**-3)/(ref_watercourses_65.length.sum()*10**-3):.3f} %')\n\n\nTotal predicted watercourse length in 1965: 55.786 km\nTotal annotated watercourse length in 1965: 59.255 km\nDifference in km: 3.469 km\n%-difference: 5.854 %\n\n\n\n\nCode\nprint(f'Total predicted watercourse length in 1984: {pred_watercourses_84.length.sum()*10**-3:.3f} km')\nprint(f'Total annotated watercourse length in 1984: {ref_watercourses_84.length.sum()*10**-3:.3f} km')\nprint(f'Difference in km: {(ref_watercourses_84.length.sum()*10**-3 - pred_watercourses_84.length.sum()*10**-3):.3f} km')\nprint(f'%-difference: {100*(ref_watercourses_84.length.sum()*10**-3 - pred_watercourses_84.length.sum()*10**-3)/(ref_watercourses_84.length.sum()*10**-3):.3f} %')\n\n\nTotal predicted watercourse length in 1984: 160.470 km\nTotal annotated watercourse length in 1984: 164.801 km\nDifference in km: 4.332 km\n%-difference: 2.628 %"
  },
  {
    "objectID": "postprocessings.html#water-bodies-1",
    "href": "postprocessings.html#water-bodies-1",
    "title": "Predictions and postprocessings",
    "section": "5.5 Water bodies",
    "text": "5.5 Water bodies\n\n\nCode\nfor r in ['213405_1965.tif', '213405_1984.tif']:\n    polygonize(respath/r, polypath/'water_bodies'/r.replace('tif', 'geojson'), target_class=5, scale_factor=1/2)\n\nfor r in ['val_mask_1965.tif', 'val_mask_1984.tif']:\n    polygonize(refpath/'postproc'/r, refpath/'polydata/water_bodies'/r.replace('tif', 'geojson'), target_class=5, scale_factor=1/2)\n\n\n\n\nCode\nfig, axs = plt.subplots(1,4, figsize=(8,4), dpi=200)\n\nfor a in axs: \n    a.set_xticks([])\n    a.set_yticks([])\n\npred_water_bodies_65 = gpd.read_file(polypath/'water_bodies/213405_1965.geojson')\nref_water_bodies_65 = gpd.read_file(refpath/'polydata/water_bodies/val_mask_1965.geojson')\npred_water_bodies_65 = pred_water_bodies_65.clip(box(*ref_water_bodies_65.total_bounds))\npred_water_bodies_65.plot(ax=axs[0]).set_title('Predicted 1965')\nref_water_bodies_65 = ref_water_bodies_65.clip(box(*pred_water_bodies_65.total_bounds))\nref_water_bodies_65.plot(ax=axs[1]).set_title('Annotated 1965')\npred_water_bodies_84 = gpd.read_file(polypath/'water_bodies/213405_1984.geojson')\nref_water_bodies_84 = gpd.read_file(refpath/'polydata/water_bodies/val_mask_1984.geojson')\npred_water_bodies_84 = pred_water_bodies_84.clip(box(*ref_water_bodies_84.total_bounds))\npred_water_bodies_84.plot(ax=axs[2]).set_title('Predicted 1984')\nref_water_bodies_84 = ref_water_bodies_84.clip(box(*pred_water_bodies_84.total_bounds))\nref_water_bodies_84.plot(ax=axs[3]).set_title('Annotated 1984')\n\nplt.tight_layout()\n\n\n\n\n\n\n\nCode\nprint(f'Total predicted water body area in 1965: {pred_water_bodies_65.area.sum()*10**-6:.3f} km²')\nprint(f'Total annotated water body area in 1965: {ref_water_bodies_65.area.sum()*10**-6:.3f} km²')\nprint(f'Difference in km²: {(ref_water_bodies_65.area.sum()*10**-6 - pred_water_bodies_65.area.sum()*10**-6):.3f} km²')\nprint(f'%-difference: {100*(ref_water_bodies_65.area.sum()*10**-6 - pred_water_bodies_65.area.sum()*10**-6)/(ref_water_bodies_65.area.sum()*10**-6):.3f} %')\n\n\nTotal predicted water body area in 1965: 2.519 km²\nTotal annotated water body area in 1965: 2.530 km²\nDifference in km²: 0.011 km²\n%-difference: 0.449 %\n\n\n\n\nCode\nprint(f'Total predicted water body area in 1984: {pred_water_bodies_84.area.sum()*10**-6:.3f} km²')\nprint(f'Total annotated water body area in 1984: {ref_water_bodies_84.area.sum()*10**-6:.3f} km²')\nprint(f'Difference in km²: {(ref_water_bodies_84.area.sum()*10**-6 - pred_water_bodies_84.area.sum()*10**-6):.3f} km²')\nprint(f'%-difference: {100*(ref_water_bodies_84.area.sum()*10**-6 - pred_water_bodies_84.area.sum()*10**-6)/(ref_water_bodies_84.area.sum()*10**-6):.3f} %')\n\n\nTotal predicted water body area in 1984: 2.463 km²\nTotal annotated water body area in 1984: 2.462 km²\nDifference in km²: -0.002 km²\n%-difference: -0.069 %"
  },
  {
    "objectID": "change_analysis.html",
    "href": "change_analysis.html",
    "title": "Change analysis",
    "section": "",
    "text": "Code\nimport geopandas as gpd\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as colors\nimport os\nfrom shapely.geometry import box\nfrom pathlib import Path\nfrom tqdm import tqdm\nimport fiona\nfrom rasterio import features\nfrom rasterio.enums import Resampling\nimport rasterio as rio\nfrom itertools import product\nfrom shapely.geometry import Polygon\nimport numpy as np\n\ntqdm.pandas()\nimport warnings\nwarnings.filterwarnings('ignore')\nAfter post-processing the results, we used them do derive land use and land cover changes for our study area."
  },
  {
    "objectID": "change_analysis.html#section",
    "href": "change_analysis.html#section",
    "title": "Change analysis",
    "section": "1.1 2005",
    "text": "1.1 2005\nTopographic database from 2005 is split into map sheets, and each of those contain several shp files. Our study is fully covered in four map sheets, M21O4D, M2104C, M20O2B and M20O2A. In addition, this dataset is in EPSG:2393 coordinates so it must be converted to EPSG:3067.\n\n\nCode\nsheets = [s for s in os.listdir(mtk_path/'2005') if os.path.isdir(mtk_path/'2005'/s)]\n\n\n\n1.1.1 Fields\nFields are found on files with template M<sheetid>P, and the class id is 32611.\n\n\nCode\nfields = None\nfor s in sheets:\n    temp = gpd.read_file(mtk_path/'2005'/s/f'M{s[1:]}P.SHP')\n    temp = temp[temp.LUOKKA == 32611]\n    if fields is None: fields = temp\n    else: fields = pd.concat([fields, temp])\n\n\n\n\nCode\nfields = fields.to_crs('EPSG:3067')\nfields = fields.clip(study_area.iloc[0].geometry)\n\n\n\n\nCode\nfields.plot()\n\n\n<AxesSubplot: >\n\n\n\n\n\n\n\nCode\nfields.to_file(mtk_path/'2005'/'fields.geojson')\n\n\n\n\n1.1.2 Mires\nMires are found on files with template M<sheetid>P, and the class ids are 35411, 35412, 35421 and 35422.\n\n\nCode\nmires = None\nfor s in sheets:\n    temp = gpd.read_file(mtk_path/'2005'/s/f'M{s[1:]}P.SHP')\n    temp = temp[temp.LUOKKA.isin([35411,35412,35421,35422])]\n    if mires is None: mires = temp\n    else: mires = pd.concat([mires, temp])\n\n\n\n\nCode\nmires = mires.to_crs('EPSG:3067')\nmires = mires.clip(study_area.iloc[0].geometry)\n\n\n\n\nCode\nmires.plot()\n\n\n<AxesSubplot: >\n\n\n\n\n\n\n\nCode\nmires['geometry'] = mires.geometry.apply(lambda row: row[0] if type(row) != Polygon else row)\nmires.to_file(mtk_path/'2005'/'mires.geojson')\n\n\n\n\n1.1.3 Roads\nRoads are found on files with template L<sheetid>V, and the class ids are 12111, 12112, 12121, 12122, 12131 and 12132.\n\n\nCode\nroads = None\nfor s in sheets:\n    temp = gpd.read_file(mtk_path/'2005'/s/f'L{s[1:]}V.SHP')\n    temp = temp[temp.LUOKKA.isin([12111,12112,12121,12122,12131,12132])]\n    if roads is None: roads = temp\n    else: roads = pd.concat([roads, temp])\n\n\n\n\nCode\nroads = roads.to_crs('EPSG:3067')\nroads = roads.clip(study_area.iloc[0].geometry)\n\n\n\n\nCode\nroads.plot()\n\n\n\n\nCode\nroads.to_file(mtk_path/'2005'/'roads.geojson')\n\n\n\n\n1.1.4 Watercourses\nWatercourses are found from files with template M<sheetid>V with class ids 36311 and 36312 as line geometries, and from files with template M<sheetid>P with class ids 36313 as polygon data. As our predictions convert all watercourses into line data, we do the same for class 36313.\n\n\nCode\nwatercourses = None\nfor s in sheets:\n    temp = gpd.read_file(mtk_path/'2005'/s/f'M{s[1:]}V.SHP')\n    temp = temp[temp.LUOKKA.isin([36311,36312])]\n    if watercourses is None: watercourses = temp\n    else: watercourses = pd.concat([watercourses, temp])\nwatercourses.reset_index(inplace=True, drop=True)\n\n\n\n\nCode\nfrom centerline.geometry import Centerline\n\nwatercoursepolys = None\nfor s in sheets:\n    temp = gpd.read_file(mtk_path/'2005'/s/f'M{s[1:]}P.SHP')\n    temp = temp[temp.LUOKKA.isin([36313])]\n    if watercoursepolys is None: watercoursepolys = temp\n    else: watercoursepolys = pd.concat([watercoursepolys, temp])\nwatercoursepolys.reset_index(inplace=True, drop=True)\nwatercoursepolys = watercoursepolys.to_crs('EPSG:3067')\nwatercoursepolys = watercoursepolys.clip(study_area.iloc[0].geometry)\nwatercoursepolys['geometry'] = watercoursepolys.progress_apply(lambda row: Centerline(row.geometry), axis=1)\n\n\n\n\nCode\nwatercourses = watercourses.to_crs('EPSG:3067')\nwatercourses = watercourses.clip(study_area.iloc[0].geometry)\nwatercourses = pd.concat([watercourses, watercoursepolys])\nwatercourses.reset_index(inplace=True, drop=True)\n\n\n\n\nCode\nwatercourses.plot(column='LUOKKA')\n\n\n\n\nCode\nwatercourses.to_file(mtk_path/'2005'/'watercourses.geojson')\n\n\n\n\n1.1.5 Water bodies\nWater bodies area on files with template M<sheetid>P, class ids are 36200.\n\n\nCode\nwaterbodies = None\nfor s in sheets:\n    temp = gpd.read_file(mtk_path/'2005'/s/f'M{s[1:]}P.SHP')\n    temp = temp[temp.LUOKKA.isin([36200])]\n    if waterbodies is None: waterbodies = temp\n    else: waterbodies = pd.concat([waterbodies, temp])\n\n\n\n\nCode\nwaterbodies = waterbodies.to_crs('EPSG:3067')\nwaterbodies = waterbodies.clip(study_area.iloc[0].geometry)\n\n\n\n\nCode\nwaterbodies.plot()\n\n\n\n\nCode\nwaterbodies.to_file(mtk_path/'2005'/'waterbodies.geojson')"
  },
  {
    "objectID": "change_analysis.html#section-1",
    "href": "change_analysis.html#section-1",
    "title": "Change analysis",
    "section": "1.2 2022",
    "text": "1.2 2022\nTopographic database from 2022 is saved as a single geodatabases for whole Finland, and the databases are:\n\nMTK-kallio contains rocks and mineral soils\nMTK-korkeussuhteet contains altitude information\nMTK-maastokuvionreuna contains the edges for some classes\nMTK-muut contains the miscillaneous classes, such as meadows and arable land\nMTK-rakennus contains buildings\nMTK-suo contains mires\nMTK-tie contains the road networks\nMTK-vakavesi contains all water bodies\nMTK-virtavesi contains all watercourses\n\nOur analyses require the usage of MTK-muut, MTK-suo, MTK-tie, MTK-vakavesi and MTK-virtavesi. The class ids are the same as in 2005, and the clipping is done beforehand with QGIS. We just convert watercourse polygons to lines and combine them with watercourse lines.\n\n\nCode\nlines = gpd.read_file(mtk_path/'2022/virtavesiviivat_2022.geojson')\npolys = gpd.read_file(mtk_path/'2022/virtavesialueet_2022.geojson')\npolys['geometry'] = polys.geometry.progress_apply(Centerline)\nwws = pd.concat([lines, polys])\nwws.reset_index(inplace=True, drop=True)\nwws.to_file(mtk_path/'2022/virtavedet_2022.geojson')"
  },
  {
    "objectID": "change_analysis.html#fields-1",
    "href": "change_analysis.html#fields-1",
    "title": "Change analysis",
    "section": "2.1 Fields",
    "text": "2.1 Fields\nFirst polygonize the results.\n\n\nCode\npolypath = Path('../results/polygons/')\nfor r in results:\n    polygonize(respath/r, polypath/'fields'/r.replace('tif', 'geojson'), target_class=1, scale_factor=1/2)\n\n\nThen put them into a single dataframe\n\n\nCode\nfields_65 = None\nfields_80s = None\n\nfor p in os.listdir(polypath/'fields'):\n    union_gdf = gpd.read_file(polypath/'fields'/p)\n    if '1965' in p:\n        if fields_65 is None: fields_65 = union_gdf\n        else: fields_65 = pd.concat((fields_65, union_gdf))\n    else:\n        if fields_80s is None: fields_80s = union_gdf\n        else: fields_80s = pd.concat((fields_80s, union_gdf))\nfields_65 = fields_65.clip(study_area.geometry.iloc[0])\nfields_80s = fields_80s.clip(study_area.geometry.iloc[0])\nfields_65.reset_index(inplace=True, drop=True)\nfields_80s.reset_index(inplace=True, drop=True)\n\n\nSave the dataframes.\n\n\nCode\nfields_65.to_file(polypath/'fields_65.geojson')\nfields_80s.to_file(polypath/'fields_80s.geojson')\n\n\n\n\nCode\nfields_05 = gpd.read_file(mtk_path/'2005/fields.geojson')\nfields_22 = gpd.read_file(mtk_path/'2022/pellot_2022.geojson')\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(10,10), dpi=150)\nfields_65.plot(ax=axs[0,0], color='tab:orange')\naxs[0,0].set_title(f'Fields 1965, total_area {(fields_65.area.sum() * 10**-6):.2f} km²')\nfields_80s.plot(ax=axs[0,1], color='tab:orange')\naxs[0,1].set_title(f'Fields 1984-1985, total_area {(fields_80s.area.sum() * 10**-6):.2f} km²')\nfields_05.plot(ax=axs[1,0], color='tab:orange')\naxs[1,0].set_title(f'Fields 2005, total_area {(fields_05.area.sum() * 10**-6):.2f} km²')\nfields_22.plot(ax=axs[1,1], color='tab:orange')\naxs[1,1].set_title(f'Fields 2022, total_area {(fields_22.area.sum() * 10**-6):.2f} km²')\n\nplt.tight_layout()\n\n\n\n\n\nFrom 1965 to 2022, the total field area has decreased by around 30 km². However, visualizing where the change has been most significant is rather difficult from the polygon data, so we aggregate the data into 500x500m grid.\n\n\nCode\ndef aggregate_area_to_grid(grid, polys, column_name):\n    tempgrid = grid[['cellid', 'geometry']].copy()\n    tempgrid = tempgrid.overlay(polys, how='intersection').dissolve(by='cellid').reset_index(drop=False)\n    tempgrid[column_name] = tempgrid.geometry.area * 10**-6\n    grid = grid.merge(tempgrid[['cellid', column_name]], how='left', on='cellid')\n    return grid\n\n\n\n\nCode\ngrid = make_grid(study_area, 500)\n\n\n\n\nCode\ngrid = aggregate_area_to_grid(grid, fields_65, 'field_area_65')\ngrid = aggregate_area_to_grid(grid, fields_80s, 'field_area_85')\ngrid = aggregate_area_to_grid(grid, fields_05, 'field_area_05')\ngrid = aggregate_area_to_grid(grid, fields_22, 'field_area_22')\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(14,10))\ngrid.fillna(0, inplace=True)\ngrid.plot(column='field_area_65', ax=axs[0,0], vmin=0, vmax=.500**2, legend=True).set_title('1965')\ngrid.plot(column='field_area_85', ax=axs[0,1], vmin=0, vmax=.500**2, legend=True).set_title('1984-1985')\ngrid.plot(column='field_area_05', ax=axs[1,0], vmin=0, vmax=.500**2, legend=True).set_title('2005')\ngrid.plot(column='field_area_22', ax=axs[1,1], vmin=0, vmax=.500**2, legend=True).set_title('2022')\nplt.tight_layout()\n\n\n\n\n\nQuantify the change. Negative change means decreased field area.\n\n\nCode\ngrid['field_change_6585'] = (grid.field_area_85 - grid.field_area_65)\ngrid['field_change_8505'] = (grid.field_area_05 - grid.field_area_85)\ngrid['field_change_0522'] = (grid.field_area_22 - grid.field_area_05)\n\n\nChange stats for 1965-1985:\n\n\nCode\nprint(f'Gain: {grid[grid.field_change_6585 > 0].field_change_6585.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.field_change_6585 < 0].field_change_6585.sum():.2f} km²')\nprint(f'Change: {grid.field_change_6585.sum():.2f} km²')\n\n\nGain: 2.32 km²\nLoss: 14.20 km²\nChange: -11.87 km²\n\n\nChange stats for 1985-2005\n\n\nCode\nprint(f'Gain: {grid[grid.field_change_8505 > 0].field_change_8505.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.field_change_8505 < 0].field_change_8505.sum():.2f} km²')\nprint(f'Change: {grid.field_change_8505.sum():.2f} km²')\n\n\nGain: 1.27 km²\nLoss: 12.85 km²\nChange: -11.57 km²\n\n\nChange stats for 2005-2022\n\n\nCode\nprint(f'Gain: {grid[grid.field_change_0522 > 0].field_change_0522.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.field_change_0522 < 0].field_change_0522.sum():.2f} km²')\nprint(f'Change: {grid.field_change_0522.sum():.2f} km²')\n\n\nGain: 1.81 km²\nLoss: 5.51 km²\nChange: -3.70 km²\n\n\n\n\nCode\nfig,axs = plt.subplots(1,4, figsize=(15,5), dpi=200, gridspec_kw={'width_ratios': [1,1,1,0.05]})\n\ngrid.plot(column='field_change_6585', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[0])\ngrid.plot(column='field_change_8505', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[1])\ngrid.plot(column='field_change_0522', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[2])\naxs[0].set_title(f'1965-1985, total change {grid.field_change_6585.sum():.2f} km²')\naxs[1].set_title(f'1985-2005, total change {grid.field_change_8505.sum():.2f} km²')\naxs[2].set_title(f'2005-2022, total change {grid.field_change_0522.sum():.2f} km²')\n\nnorm = colors.Normalize(vmin=-.2,vmax=.2)\nsm = plt.cm.ScalarMappable(cmap='seismic', norm=norm)\nticks = [-.2,-.1,0,.1,.2]\ncbar = plt.colorbar(sm, cax=axs[3], ticks=ticks)\ncbar.ax.set_yticklabels([f'{t} km²' for t in ticks])\nplt.suptitle('Changes in field area, aggregated to 500x500m grid')\nplt.show()\n\n\n\n\n\nVisualize the location where the field area has decreased the most between 1965 and 1985. For 1965 and 1980s show the corresponding map patch along with the data.\n\n\nCode\nfrom shapely.geometry import box\nfrom rasterio.windows import from_bounds\n\ndef get_map_patch(bbox, year, map_path):\n    \"Get map patch to go along with the desired location\"\n    if year == 1965: files = [f for f in os.listdir(map_path) if '1965' in f]\n    else: files = [f for f in os.listdir(map_path) if '1965' not in f]\n    for f in files:\n        with rio.open(map_path/f) as src:\n            tot_bounds = src.bounds\n            if not bbox.within(box(*tot_bounds)): continue\n            data = src.read(window=from_bounds(*bbox.bounds, src.transform))\n    return np.moveaxis(data, 0, 2)\n\n\nFor 2005 and 2022, show the closest aerial image to that year. Unfortunately the closest historical images available are from 1949 and 1979, so we can’t really use them for visualizations.\n\n\nCode\nimport owslib.wcs as wcs\nimport io\n\ndef get_wcs_img(bounds, year):\n    mml_wcs_url = 'https://beta-karttakuva.maanmittauslaitos.fi/ortokuvat-ja-korkeusmallit/wcs/v1'\n    mml_wcs = wcs.WebCoverageService(mml_wcs_url)#, version='2.0.1')\n    orig_year = year\n    tries = 0\n    while True:\n        if year < 2009: layer = 'ortokuva_mustavalko'\n        else: layer = 'ortokuva_vari'\n        img_rgb = mml_wcs.getCoverage(identifier=[layer],\n                                      crs='EPSG:3067',\n                                      subsets=[('E', bounds[0], bounds[2]), \n                                               ('N', bounds[1], bounds[3]), \n                                               ('time', f'{year}-12-31T00:00:00.000Z')],\n                                      format='image/tiff')\n        image = io.BytesIO(img_rgb.read())\n        with rio.open(image) as src:\n            data = src.read()\n        if data.max() != data.min(): break\n        tries += 1\n        year = year - tries if tries%2 == 0 else year + tries\n    finalyear = year    \n    return np.moveaxis(data, 0, 2), finalyear\n\n\n\n\nCode\nmap_path = Path('../data/maps/aligned_maps/')\nfieldloss_6585_cellid = grid[grid.field_change_6585 == grid.field_change_6585.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == fieldloss_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nfields_65.clip(grid[grid.cellid == fieldloss_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:orange').set_title('Fields in 1965')\ngrid[grid.cellid == fieldloss_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nfields_80s.clip(grid[grid.cellid == fieldloss_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:orange').set_title('Fields in 1985')\n\nimg = get_map_patch(grid[grid.cellid == fieldloss_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == fieldloss_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\nSame for 1985 and 2005\n\n\nCode\nfieldloss_8505_cellid = grid[grid.field_change_8505 == grid.field_change_8505.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == fieldloss_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nfields_80s.clip(grid[grid.cellid == fieldloss_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:orange').set_title('Fields in 1985')\ngrid[grid.cellid == fieldloss_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nfields_05.clip(grid[grid.cellid == fieldloss_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:orange').set_title('Fields in 2005')\n\nimg = get_map_patch(grid[grid.cellid == fieldloss_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == fieldloss_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()\n\n\n\n\n\nAnd then same visualizations for field area increase.\n\n\nCode\nfieldgain_6585_cellid = grid[grid.field_change_6585 == grid.field_change_6585.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == fieldgain_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nfields_65.clip(grid[grid.cellid == fieldgain_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:orange').set_title('Fields in 1965')\ngrid[grid.cellid == fieldgain_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nfields_80s.clip(grid[grid.cellid == fieldgain_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:orange').set_title('Fields in 1985')\n\nimg = get_map_patch(grid[grid.cellid == fieldgain_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == fieldgain_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\n\n\nCode\nfieldgain_8505_cellid = grid[grid.field_change_8505 == grid.field_change_8505.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == fieldgain_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nfields_80s.clip(grid[grid.cellid == fieldgain_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:orange').set_title('Fields in 1985')\ngrid[grid.cellid == fieldgain_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nfields_05.clip(grid[grid.cellid == fieldgain_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:orange').set_title('Fields in 2005')\n\nimg = get_map_patch(grid[grid.cellid == fieldgain_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == fieldgain_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()"
  },
  {
    "objectID": "change_analysis.html#mires-1",
    "href": "change_analysis.html#mires-1",
    "title": "Change analysis",
    "section": "2.2 Mires",
    "text": "2.2 Mires\nPolygonize and put to single geojson files.\n\n\nCode\nfor r in results:\n    polygonize(respath/r, polypath/'mires'/r.replace('tif', 'geojson'), target_class=2, scale_factor=1/2)\n\n\n\n\nCode\nmires_65 = None\nmires_80s = None\n\nfor p in os.listdir(polypath/'mires'):\n    union_gdf = gpd.read_file(polypath/'mires'/p)\n    if '1965' in p:\n        if mires_65 is None: mires_65 = union_gdf\n        else: mires_65 = pd.concat((mires_65, union_gdf))\n    else:\n        if mires_80s is None: mires_80s = union_gdf\n        else: mires_80s = pd.concat((mires_80s, union_gdf))\nmires_65 = mires_65.clip(study_area.geometry.iloc[0])\nmires_80s = mires_80s.clip(study_area.geometry.iloc[0])\nmires_65.reset_index(inplace=True, drop=True)\nmires_80s.reset_index(inplace=True, drop=True)\n\n\n\n\nCode\nmires_65.to_file(polypath/'mires_65.geojson')\nmires_80s.to_file(polypath/'mires_80s.geojson')\n\n\n\n\nCode\nmires_05 = gpd.read_file(mtk_path/'2005/mires.geojson')\nmires_22 = gpd.read_file(mtk_path/'2022/suot_2022.geojson')\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(10,10), dpi=150)\nmires_65.plot(ax=axs[0,0], color='tab:gray')\naxs[0,0].set_title(f'Mires 1965, total_area {(mires_65.area.sum() * 10**-6):.2f} km²')\nmires_80s.plot(ax=axs[0,1], color='tab:gray')\naxs[0,1].set_title(f'Mires 1984-1985, total_area {(mires_80s.area.sum() * 10**-6):.2f} km²')\nmires_05.plot(ax=axs[1,0], color='tab:gray')\naxs[1,0].set_title(f'Mires 2005, total_area {(mires_05.area.sum() * 10**-6):.2f} km²')\nmires_22.plot(ax=axs[1,1], color='tab:gray')\naxs[1,1].set_title(f'Mires 2022, total_area {(mires_22.area.sum() * 10**-6):.2f} km²')\n\nplt.tight_layout()\n\n\n\n\n\nThe difference between the total areas of mires between years can be explained by more accurate mapping methods, or restoration processes.\nPut the data into the grid.\n\n\nCode\ngrid = aggregate_area_to_grid(grid, mires_65, 'mire_area_65')\ngrid = aggregate_area_to_grid(grid, mires_80s, 'mire_area_85')\ngrid = aggregate_area_to_grid(grid, mires_05, 'mire_area_05')\ngrid = aggregate_area_to_grid(grid, mires_22, 'mire_area_22')\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(14,10))\ngrid.fillna(0, inplace=True)\ngrid.plot(column='mire_area_65', ax=axs[0,0], vmin=0, vmax=.500**2, legend=True).set_title('1965')\ngrid.plot(column='mire_area_85', ax=axs[0,1], vmin=0, vmax=.500**2, legend=True).set_title('1984-1985')\ngrid.plot(column='mire_area_05', ax=axs[1,0], vmin=0, vmax=.500**2, legend=True).set_title('2005')\ngrid.plot(column='mire_area_22', ax=axs[1,1], vmin=0, vmax=.500**2, legend=True).set_title('2022')\nplt.tight_layout()\n\n\n\n\n\nQuantify the change. Negative change means decreased mire area.\n\n\nCode\ngrid['mire_change_6585'] = (grid.mire_area_85 - grid.mire_area_65)\ngrid['mire_change_8505'] = (grid.mire_area_05 - grid.mire_area_85)\ngrid['mire_change_0522'] = (grid.mire_area_22 - grid.mire_area_05)\n\n\nChange stats for 1965-1985:\n\n\nCode\nprint(f'Gain: {grid[grid.mire_change_6585 > 0].mire_change_6585.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.mire_change_6585 < 0].mire_change_6585.sum():.2f} km²')\nprint(f'Change: {grid.mire_change_6585.sum():.2f} km²')\n\n\nGain: 15.86 km²\nLoss: 5.92 km²\nChange: 9.95 km²\n\n\nChange stats for 1985-2005\n\n\nCode\nprint(f'Gain: {grid[grid.mire_change_8505 > 0].mire_change_8505.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.mire_change_8505 < 0].mire_change_8505.sum():.2f} km²')\nprint(f'Change: {grid.mire_change_8505.sum():.2f} km²')\n\n\nGain: 1.74 km²\nLoss: 8.72 km²\nChange: -6.98 km²\n\n\nChange stats for 2005-2022\n\n\nCode\nprint(f'Gain: {grid[grid.mire_change_0522 > 0].mire_change_0522.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.mire_change_0522 < 0].mire_change_0522.sum():.2f} km²')\nprint(f'Change: {grid.mire_change_0522.sum():.2f} km²')\n\n\nGain: 8.04 km²\nLoss: 1.14 km²\nChange: 6.90 km²\n\n\n\n\nCode\nfig,axs = plt.subplots(1,4, figsize=(15,5), dpi=200, gridspec_kw={'width_ratios': [1,1,1,0.05]})\n\ngrid.plot(column='mire_change_6585', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[0])\ngrid.plot(column='mire_change_8505', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[1])\ngrid.plot(column='mire_change_0522', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[2])\naxs[0].set_title(f'1965-1985, total change {grid.mire_change_6585.sum():.2f} km²')\naxs[1].set_title(f'1985-2005, total change {grid.mire_change_8505.sum():.2f} km²')\naxs[2].set_title(f'2005-2022, total change {grid.mire_change_0522.sum():.2f} km²')\n\nnorm = colors.Normalize(vmin=-.2,vmax=.2)\nsm = plt.cm.ScalarMappable(cmap='seismic', norm=norm)\nticks = [-.2,-.1,0,.1,.2]\ncbar = plt.colorbar(sm, cax=axs[3], ticks=ticks)\ncbar.ax.set_yticklabels([f'{t} km²' for t in ticks])\nplt.suptitle('Changes in mire area, aggregated to 500x500m grid')\nplt.show()\n\n\n\n\n\nVisualize the location where the mire area has decreased the most between 1965 and 1985. For 1965 and 1980s show the corresponding map patch along with the data.\nFor 2005 and 2022, show the closest aerial image to that year. Unfortunately the closest historical images available are from 1949 and 1979, so we can’t really use them for visualizations.\n\n\nCode\nmireloss_6585_cellid = grid[grid.mire_change_6585 == grid.mire_change_6585.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == mireloss_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nmires_65.clip(grid[grid.cellid == mireloss_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:gray').set_title('mires in 1965')\ngrid[grid.cellid == mireloss_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nmires_80s.clip(grid[grid.cellid == mireloss_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:gray').set_title('mires in 1985')\n\nimg = get_map_patch(grid[grid.cellid == mireloss_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == mireloss_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\n\n\nText(0.5, 1.0, 'Map patch from 1980s')\n\n\n\n\n\nSame for 1985 and 2005\n\n\nCode\nmireloss_8505_cellid = grid[grid.mire_change_8505 == grid.mire_change_8505.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == mireloss_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nmires_80s.clip(grid[grid.cellid == mireloss_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:gray').set_title('mires in 1985')\ngrid[grid.cellid == mireloss_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nmires_05.clip(grid[grid.cellid == mireloss_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:gray').set_title('mires in 2005')\n\nimg = get_map_patch(grid[grid.cellid == mireloss_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == mireloss_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\n\n\nText(0.5, 1.0, 'Aerial image from 2008')\n\n\n\n\n\nAnd then same visualizations for mire area increase.\n\n\nCode\nmiregain_6585_cellid = grid[grid.mire_change_6585 == grid.mire_change_6585.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == miregain_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nmires_65.clip(grid[grid.cellid == miregain_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:gray').set_title('mires in 1965')\ngrid[grid.cellid == miregain_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nmires_80s.clip(grid[grid.cellid == miregain_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:gray').set_title('mires in 1985')\n\nimg = get_map_patch(grid[grid.cellid == miregain_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == miregain_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\n\n\nText(0.5, 1.0, 'Map patch from 1980s')\n\n\n\n\n\n\n\nCode\nmiregain_8505_cellid = grid[grid.mire_change_8505 == grid.mire_change_8505.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == miregain_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nmires_80s.clip(grid[grid.cellid == miregain_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:gray').set_title('mires in 1985')\ngrid[grid.cellid == miregain_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nmires_05.clip(grid[grid.cellid == miregain_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:gray').set_title('mires in 2005')\n\nimg = get_map_patch(grid[grid.cellid == miregain_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == miregain_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\n\n\nText(0.5, 1.0, 'Aerial image from 2008')"
  },
  {
    "objectID": "change_analysis.html#roads-1",
    "href": "change_analysis.html#roads-1",
    "title": "Change analysis",
    "section": "2.3 Roads",
    "text": "2.3 Roads\n\n\nCode\nroad_path = Path('../results/lines/roads/')\n\nroads_65 = None\nroads_80s = None\n\nfor p in os.listdir(road_path):\n    union_gdf = gpd.read_file(road_path/p)\n    if '1965' in p:\n        if roads_65 is None: roads_65 = union_gdf\n        else: roads_65 = pd.concat((roads_65, union_gdf))\n    else:\n        if roads_80s is None: roads_80s = union_gdf\n        else: roads_80s = pd.concat((roads_80s, union_gdf))\n\nroads_65 = roads_65[roads_65.geometry.length > 100]\nroads_80s = roads_80s[roads_80s.geometry.length > 100]       \nroads_65 = roads_65.clip(study_area.geometry.iloc[0])\nroads_80s = roads_80s.clip(study_area.geometry.iloc[0])\nroads_65.reset_index(drop=True, inplace=True)\nroads_80s.reset_index(drop=True, inplace=True)\n\nroads_05 = gpd.read_file(mtk_path/'2005/roads.geojson')\nroads_22 = gpd.read_file(mtk_path/'2022/tiet_2022.geojson')\nroads_22 = roads_22[roads_22.kohdeluokka.isin([12111,12112,12121,12122,12131,12132])]\n\n\nFor roads, we can see the overall change in the road networks and approximate total length.\n\n\nCode\nfig, axs = plt.subplots(2,2, dpi=200, figsize=(11,11))\n\nroads_65.plot(ax=axs[0,0])\nroads_80s.plot(ax=axs[0,1])\nroads_05.plot(ax=axs[1,0])\nroads_22.plot(ax=axs[1,1])\naxs[0,0].set_title(f'Roads 1965, total length {roads_65.length.sum() * 10**-3:.2f} km')\naxs[0,1].set_title(f'Roads 1985, total length {roads_80s.length.sum() * 10**-3:.2f} km')\naxs[1,0].set_title(f'Roads 2005, total length {roads_05.length.sum() * 10**-3:.2f} km')\naxs[1,1].set_title(f'Roads 2022, total length {roads_22.length.sum() * 10**-3:.2f} km')\nplt.show()\n\n\n\n\n\n\n\nCode\ndef get_len(cell, targs, sindex):\n    nearest_idx = list(sindex.nearest(cell.geometry.bounds))\n    tempdata = targs.iloc[nearest_idx]\n    return tempdata.clip(cell.geometry, keep_geom_type=True).length.sum() * 10**-3\n\n\n\n\nCode\ngrid['road_length_65'] = grid.progress_apply(lambda cell: get_len(cell, roads_65, roads_65.sindex), axis=1)\ngrid['road_length_85'] = grid.progress_apply(lambda cell: get_len(cell, roads_80s, roads_80s.sindex), axis=1)\ngrid['road_length_05'] = grid.progress_apply(lambda cell: get_len(cell, roads_05, roads_05.sindex), axis=1)\ngrid['road_length_22'] = grid.progress_apply(lambda cell: get_len(cell, roads_22, roads_22.sindex), axis=1)\n\n\n100%|████████████████████████████████████████████████████████████████████████████| 4032/4032 [00:19<00:00, 211.94it/s]\n100%|████████████████████████████████████████████████████████████████████████████| 4032/4032 [00:19<00:00, 203.38it/s]\n100%|████████████████████████████████████████████████████████████████████████████| 4032/4032 [00:16<00:00, 249.25it/s]\n100%|████████████████████████████████████████████████████████████████████████████| 4032/4032 [00:16<00:00, 244.59it/s]\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(14,10))\ngrid.fillna(0, inplace=True)\ngrid.plot(column='road_length_65', ax=axs[0,0], vmin=0, vmax=2.5, legend=True).set_title('1965')\ngrid.plot(column='road_length_85', ax=axs[0,1], vmin=0, vmax=2.5, legend=True).set_title('1984-1985')\ngrid.plot(column='road_length_05', ax=axs[1,0], vmin=0, vmax=2.5, legend=True).set_title('2005')\ngrid.plot(column='road_length_22', ax=axs[1,1], vmin=0, vmax=2.5, legend=True).set_title('2022')\nplt.tight_layout()\n\n\n\n\n\nQuantify the change. Negative change means decreased road length.\n\n\nCode\ngrid['road_change_6585'] = (grid.road_length_85 - grid.road_length_65)\ngrid['road_change_8505'] = (grid.road_length_05 - grid.road_length_85)\ngrid['road_change_0522'] = (grid.road_length_22 - grid.road_length_05)\n\n\nChange stats for 1965-1985:\n\n\nCode\nprint(f'Gain: {grid[grid.road_change_6585 > 0].road_change_6585.sum():.2f} km')\nprint(f'Loss: {-grid[grid.road_change_6585 < 0].road_change_6585.sum():.2f} km')\nprint(f'Change: {grid.road_change_6585.sum():.2f} km')\n\n\nGain: 72.54 km\nLoss: 28.55 km\nChange: 43.99 km\n\n\nChange stats for 1985-2005\n\n\nCode\nprint(f'Gain: {grid[grid.road_change_8505 > 0].road_change_8505.sum():.2f} km')\nprint(f'Loss: {-grid[grid.road_change_8505 < 0].road_change_8505.sum():.2f} km')\nprint(f'Change: {grid.road_change_8505.sum():.2f} km')\n\n\nGain: 49.61 km\nLoss: 13.30 km\nChange: 36.31 km\n\n\nChange stats for 2005-2022\n\n\nCode\nprint(f'Gain: {grid[grid.road_change_0522 > 0].road_change_0522.sum():.2f} km')\nprint(f'Loss: {-grid[grid.road_change_0522 < 0].road_change_0522.sum():.2f} km')\nprint(f'Change: {grid.road_change_0522.sum():.2f} km')\n\n\nGain: 12.79 km\nLoss: 4.24 km\nChange: 8.56 km\n\n\n\n\nCode\nfig,axs = plt.subplots(1,4, figsize=(15,5), dpi=200, gridspec_kw={'width_ratios': [1,1,1,0.05]})\n\ngrid.plot(column='road_change_6585', cmap='seismic', vmin=-1, vmax=1, ax=axs[0])\ngrid.plot(column='road_change_8505', cmap='seismic', vmin=-1, vmax=1, ax=axs[1])\ngrid.plot(column='road_change_0522', cmap='seismic', vmin=-1, vmax=1, ax=axs[2])\naxs[0].set_title(f'1965-1985, total change {grid.road_change_6585.sum():.2f} km')\naxs[1].set_title(f'1985-2005, total change {grid.road_change_8505.sum():.2f} km')\naxs[2].set_title(f'2005-2022, total change {grid.road_change_0522.sum():.2f} km')\n\nnorm = colors.Normalize(vmin=-1.5,vmax=1.5)\nsm = plt.cm.ScalarMappable(cmap='seismic', norm=norm)\nticks = [-1.5,-0.75,0,0.75,1.5]\ncbar = plt.colorbar(sm, cax=axs[3], ticks=ticks)\ncbar.ax.set_yticklabels([f'{t} km' for t in ticks])\nplt.suptitle('Changes in road length, aggregated to 500x500m grid')\nplt.show()\n\n\n\n\n\nVisualize the location where the road length has decreased the most between 1965 and 1985. For 1965 and 1980s show the corresponding map patch along with the data.\nFor 2005 and 2022, show the closest aerial image to that year. Unfortunately the closest historical images available are from 1949 and 1979, so we can’t really use them for visualizations.\n\n\nCode\nmap_path = Path('../data/maps/aligned_maps/')\nroadloss_6585_cellid = grid[grid.road_change_6585 == grid.road_change_6585.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == roadloss_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nroads_65.clip(grid[grid.cellid == roadloss_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:red').set_title('roads in 1965')\ngrid[grid.cellid == roadloss_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nroads_80s.clip(grid[grid.cellid == roadloss_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:red').set_title('roads in 1985')\n\nimg = get_map_patch(grid[grid.cellid == roadloss_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == roadloss_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\nSame for 1985 and 2005\n\n\nCode\nroadloss_8505_cellid = grid[grid.road_change_8505 == grid.road_change_8505.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == roadloss_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nroads_80s.clip(grid[grid.cellid == roadloss_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:red').set_title('roads in 1985')\ngrid[grid.cellid == roadloss_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nroads_05.clip(grid[grid.cellid == roadloss_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:red').set_title('roads in 2005')\n\nimg = get_map_patch(grid[grid.cellid == roadloss_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == roadloss_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()\n\n\n\n\n\nAnd then same visualizations for road length increase.\n\n\nCode\nroadgain_6585_cellid = grid[grid.road_change_6585 == grid.road_change_6585.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == roadgain_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nroads_65.clip(grid[grid.cellid == roadgain_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:red').set_title('roads in 1965')\ngrid[grid.cellid == roadgain_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nroads_80s.clip(grid[grid.cellid == roadgain_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:red').set_title('roads in 1985')\n\nimg = get_map_patch(grid[grid.cellid == roadgain_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == roadgain_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\n\n\nCode\nroadgain_8505_cellid = grid[grid.road_change_8505 == grid.road_change_8505.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == roadgain_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nroads_80s.clip(grid[grid.cellid == roadgain_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:red').set_title('roads in 1985')\ngrid[grid.cellid == roadgain_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nroads_05.clip(grid[grid.cellid == roadgain_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:red').set_title('roads in 2005')\n\nimg = get_map_patch(grid[grid.cellid == roadgain_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == roadgain_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()"
  },
  {
    "objectID": "change_analysis.html#watercourses-1",
    "href": "change_analysis.html#watercourses-1",
    "title": "Change analysis",
    "section": "2.4 Watercourses",
    "text": "2.4 Watercourses\n\n\nCode\nww_path = Path('../results/lines/watercourses/')\n\nwatercourses_65 = None\nwatercourses_80s = None\n\nfor p in os.listdir(ww_path):\n    union_gdf = gpd.read_file(ww_path/p)\n    if '1965' in p:\n        if watercourses_65 is None: watercourses_65 = union_gdf\n        else: watercourses_65 = pd.concat((watercourses_65, union_gdf))\n    else:\n        if watercourses_80s is None: watercourses_80s = union_gdf\n        else: watercourses_80s = pd.concat((watercourses_80s, union_gdf))\nmires_65 = mires_65.clip(study_area.geometry.iloc[0])\nmires_80s = mires_80s.clip(study_area.geometry.iloc[0])\nwatercourses_65.reset_index(drop=True, inplace=True)\nwatercourses_80s.reset_index(drop=True, inplace=True)\n\nwatercourses_05 = gpd.read_file(mtk_path/'2005/watercourses.geojson')\nwatercourses_22 = gpd.read_file(mtk_path/'2022/virtavedet_2022.geojson')\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(10,10), dpi=150)\nwatercourses_65.plot(ax=axs[0,0], color='tab:cyan', linewidth=.2)\naxs[0,0].set_title(f'Watercourses 1965, total length {(watercourses_65.length.sum() * 10**-3):.2f} km')\nwatercourses_80s.plot(ax=axs[0,1], color='tab:cyan', linewidth=.2)\naxs[0,1].set_title(f'Watercourses 1985, total length {(watercourses_80s.length.sum() * 10**-3):.2f} km')\nwatercourses_05.plot(ax=axs[1,0], color='tab:cyan', linewidth=.2)\naxs[1,0].set_title(f'Watercourses 2005, total length {(watercourses_05.length.sum() * 10**-3):.2f} km')\nwatercourses_22.plot(ax=axs[1,1], color='tab:cyan', linewidth=.2)\naxs[1,1].set_title(f'Watercourses 2022, total length {(watercourses_22.length.sum() * 10**-3):.2f} km')\n\nplt.tight_layout()\n\n\n\n\n\nAgain, to make finding the ditching hotspots easier, aggregate the data into 500x500m grid.\n\n\nCode\ngrid['watercourse_length_65'] = grid.progress_apply(lambda cell: get_len(cell, watercourses_65, watercourses_65.sindex), axis=1)\ngrid['watercourse_length_85'] = grid.progress_apply(lambda cell: get_len(cell, watercourses_80s, watercourses_80s.sindex), axis=1)\ngrid['watercourse_length_05'] = grid.progress_apply(lambda cell: get_len(cell, watercourses_05, watercourses_05.sindex), axis=1)\ngrid['watercourse_length_22'] = grid.progress_apply(lambda cell: get_len(cell, watercourses_22, watercourses_22.sindex), axis=1)\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(15,12), dpi=200)\ngrid.plot(column='watercourse_length_65', ax=axs[0,0], vmin=0, vmax=7, legend=True)\naxs[0,0].set_title(f'Total length (km) of watercourses in 1965: \\n{grid.watercourse_length_65.sum() :.2f}km')\ngrid.plot(column='watercourse_length_85', ax=axs[0,1], vmin=0, vmax=7, legend=True)\naxs[0,1].set_title(f'Total length (km) of watercourses in 1985: \\n{grid.watercourse_length_85.sum() :.2f}km')\ngrid.plot(column='watercourse_length_05', ax=axs[1,0], vmin=0, vmax=7, legend=True)\naxs[1,0].set_title(f'Total length (km) of watercourses in 2005: \\n{grid.watercourse_length_05.sum() :.2f}km')\ngrid.plot(column='watercourse_length_22', ax=axs[1,1], vmin=0, vmax=7, legend=True)\naxs[1,1].set_title(f'Total length (km) of watercourses in 2022: \\n{grid.watercourse_length_22.sum() :.2f}km')\n\nplt.suptitle('Length of watercourses in 500x500m grid')\nplt.show()\n\n\n\n\n\nThen visualize the changes between the years.\n\n\nCode\ngrid['watercourse_change_6585'] = (grid.watercourse_length_85 - grid.watercourse_length_65) \ngrid['watercourse_change_8505'] = (grid.watercourse_length_05 - grid.watercourse_length_85) \ngrid['watercourse_change_0522'] = (grid.watercourse_length_22 - grid.watercourse_length_05)\n\n\nChange stats for 1965-1985:\n\n\nCode\nprint(f'Gain: {grid[grid.watercourse_change_6585 > 0].watercourse_change_6585.sum():.2f} km')\nprint(f'Loss: {-grid[grid.watercourse_change_6585 < 0].watercourse_change_6585.sum():.2f} km')\nprint(f'Change: {grid.watercourse_change_6585.sum():.2f} km')\n\n\nGain: 1473.98 km\nLoss: 89.17 km\nChange: 1384.81 km\n\n\nChange stats for 1985-2005\n\n\nCode\nprint(f'Gain: {grid[grid.watercourse_change_8505 > 0].watercourse_change_8505.sum():.2f} km')\nprint(f'Loss: {-grid[grid.watercourse_change_8505 < 0].watercourse_change_8505.sum():.2f} km')\nprint(f'Change: {grid.watercourse_change_8505.sum():.2f} km')\n\n\nGain: 689.11 km\nLoss: 94.68 km\nChange: 594.43 km\n\n\nChange stats for 2005-2022\n\n\nCode\nprint(f'Gain: {grid[grid.watercourse_change_0522 > 0].watercourse_change_0522.sum():.2f} km')\nprint(f'Loss: {-grid[grid.watercourse_change_0522 < 0].watercourse_change_0522.sum():.2f} km')\nprint(f'Change: {grid.watercourse_change_0522.sum():.2f} km')\n\n\nGain: 281.52 km\nLoss: 107.85 km\nChange: 173.67 km\n\n\n\n\nCode\nimport matplotlib.colors as colors\n\nfig, axs = plt.subplots(1,4, figsize=(17,5), dpi=200, gridspec_kw={'width_ratios': [1,1,1,0.05]})\ngrid.plot(column='watercourse_change_6585', ax=axs[0], vmin=-5, vmax=5, cmap='seismic')\ngrid.plot(column='watercourse_change_8505', ax=axs[1], vmin=-5, vmax=5, cmap='seismic')\ngrid.plot(column='watercourse_change_0522', ax=axs[2], vmin=-5, vmax=5, cmap='seismic')\naxs[0].set_title('1965-1985')\naxs[1].set_title('1985-2005')\naxs[2].set_title('2005-2022')\n\nnorm = colors.Normalize(vmin=-5,vmax=5)\nsm = plt.cm.ScalarMappable(cmap='seismic', norm=norm)\nticks = [-5,-4,-3,-2,-1,0,1,2,3,4,5]\ncbar = plt.colorbar(sm, cax=axs[3], ticks=ticks)\ncbar.ax.set_yticklabels([f'{t} km' for t in ticks])\nplt.suptitle('Changes in watercourse lengths, aggregated to 500x500m grid')\nplt.show()\n\n\n\n\n\nVisualize the locations where there has been the most decrease in watercourse length between 1965 and 1985.\n\n\nCode\nwatercourseloss_6585_cellid = grid[grid.watercourse_change_6585 == grid.watercourse_change_6585.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == watercourseloss_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nwatercourses_65.clip(grid[grid.cellid == watercourseloss_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:cyan').set_title('watercourses in 1965')\ngrid[grid.cellid == watercourseloss_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nwatercourses_80s.clip(grid[grid.cellid == watercourseloss_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:cyan').set_title('watercourses in 1985')\n\nimg = get_map_patch(grid[grid.cellid == watercourseloss_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == watercourseloss_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\nSame for 1985 and 2005\n\n\nCode\nwatercourseloss_8505_cellid = grid[grid.watercourse_change_8505 == grid.watercourse_change_8505.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == watercourseloss_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nwatercourses_80s.clip(grid[grid.cellid == watercourseloss_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:cyan').set_title('watercourses in 1985')\ngrid[grid.cellid == watercourseloss_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nwatercourses_05.clip(grid[grid.cellid == watercourseloss_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:cyan').set_title('watercourses in 2005')\n\nimg = get_map_patch(grid[grid.cellid == watercourseloss_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == watercourseloss_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()\n\n\n\n\n\nAnd then same visualizations for watercourse length increase.\n\n\nCode\nwatercoursegain_6585_cellid = grid[grid.watercourse_change_6585 == grid.watercourse_change_6585.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == watercoursegain_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nwatercourses_65.clip(grid[grid.cellid == watercoursegain_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:cyan').set_title('watercourses in 1965')\ngrid[grid.cellid == watercoursegain_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nwatercourses_80s.clip(grid[grid.cellid == watercoursegain_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:cyan').set_title('watercourses in 1985')\n\nimg = get_map_patch(grid[grid.cellid == watercoursegain_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == watercoursegain_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\n\n\nCode\nwatercoursegain_8505_cellid = grid[grid.watercourse_change_8505 == grid.watercourse_change_8505.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == watercoursegain_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nwatercourses_80s.clip(grid[grid.cellid == watercoursegain_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:cyan').set_title('watercourses in 1985')\ngrid[grid.cellid == watercoursegain_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nwatercourses_05.clip(grid[grid.cellid == watercoursegain_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:cyan').set_title('watercourses in 2005')\n\nimg = get_map_patch(grid[grid.cellid == watercoursegain_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == watercoursegain_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()\n\n\n\n\n\nThe example above shows the difficulty of distinguishing between water bodies and watercourses, and how converting some watercourses into line geometries may fail. See a better example with the fifth highest.\n\n\nCode\nwatercoursegain_8505_cellid = grid[grid.watercourse_change_8505 == np.partition(grid.watercourse_change_8505.values, -5)[-5]].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == watercoursegain_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nwatercourses_80s.clip(grid[grid.cellid == watercoursegain_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:cyan').set_title('watercourses in 1985')\ngrid[grid.cellid == watercoursegain_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nwatercourses_05.clip(grid[grid.cellid == watercoursegain_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:cyan').set_title('watercourses in 2005')\n\nimg = get_map_patch(grid[grid.cellid == watercoursegain_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == watercoursegain_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()\n\n\n\n\n\n\n2.4.1 Field-watercourse -combinations\nCheck how ditching has changed in fields, e.g. does shift to sub-surface drainage systems show in these data.\n\n\nCode\nfields_65['drainage_len'] = fields_65.progress_apply(lambda row: get_len(row, watercourses_65, watercourses_65.sindex), axis=1)\nfields_80s['drainage_len'] = fields_80s.progress_apply(lambda row: get_len(row, watercourses_80s, watercourses_80s.sindex), axis=1)\nfields_05['drainage_len'] = fields_05.progress_apply(lambda row: get_len(row, watercourses_05, watercourses_05.sindex), axis=1)\nfields_22['drainage_len'] = fields_22.progress_apply(lambda row: get_len(row, watercourses_22, watercourses_22.sindex), axis=1)\n\n\n\n\nCode\nprint(f'Total length of waterways in fields in 1965: {fields_65.drainage_len.sum():.2f} km') \nprint(f'Total length of waterways in fields in 1985: {fields_80s.drainage_len.sum():.2f} km') \nprint(f'Total length of waterways in fields in 2005: {fields_05.drainage_len.sum():.2f} km') \nprint(f'Total length of waterways in fields in 2022: {fields_22.drainage_len.sum():.2f} km') \n\n\nTotal length of waterways in fields in 1965: 266.62 km\nTotal length of waterways in fields in 1985: 273.78 km\nTotal length of waterways in fields in 2005: 194.06 km\nTotal length of waterways in fields in 2022: 166.73 km\n\n\n\n\n2.4.2 Mire-watercourse -combinations\n\n\nCode\nmires_65['drainage_len'] = mires_65.progress_apply(lambda row: get_len(row, watercourses_65, watercourses_65.sindex), axis=1)\nmires_80s['drainage_len'] = mires_80s.progress_apply(lambda row: get_len(row, watercourses_80s, watercourses_80s.sindex), axis=1)\nmires_05['drainage_len'] = mires_05.progress_apply(lambda row: get_len(row, watercourses_05, watercourses_05.sindex), axis=1)\nmires_22['drainage_len'] = mires_22.progress_apply(lambda row: get_len(row, watercourses_22, watercourses_22.sindex), axis=1)\n\n\n\n\nCode\nprint(f'Total length of waterways in mires in 1965: {mires_65.drainage_len.sum():.2f} km') \nprint(f'Total length of waterways in mires in 1985: {mires_80s.drainage_len.sum():.2f} km') \nprint(f'Total length of waterways in mires in 2005: {mires_05.drainage_len.sum():.2f} km') \nprint(f'Total length of waterways in mires in 2022: {mires_22.drainage_len.sum():.2f} km') \n\n\nTotal length of waterways in mires in 1965: 447.12 km\nTotal length of waterways in mires in 1985: 1604.50 km\nTotal length of waterways in mires in 2005: 1925.36 km\nTotal length of waterways in mires in 2022: 2104.92 km\n\n\nWatercourse changes can indicating ditching or restoration can be visualized for mires area. In this example, we use the mire layer from 1965 maps as the aggregation layer.\n\n\nCode\nmires_65['drainage_len_65'] = mires_65.progress_apply(lambda row: get_len(row, watercourses_65, watercourses_65.sindex), axis=1)\nmires_65['drainage_len_85'] = mires_65.progress_apply(lambda row: get_len(row, watercourses_80s, watercourses_80s.sindex), axis=1)\nmires_65['drainage_len_05'] = mires_65.progress_apply(lambda row: get_len(row, watercourses_05, watercourses_05.sindex), axis=1)\nmires_65['drainage_len_22'] = mires_65.progress_apply(lambda row: get_len(row, watercourses_22, watercourses_22.sindex), axis=1)\n\n\n\n\nCode\nmires_65['drain_change_6585'] = (mires_65.drainage_len_85 - mires_65.drainage_len_65)\nmires_65['drain_change_8505'] = (mires_65.drainage_len_05 - mires_65.drainage_len_85)\nmires_65['drain_change_0522'] = (mires_65.drainage_len_22 - mires_65.drainage_len_05)\n\n\nFilter out the mire where the ditching has been the most aggressive between 1965 and 1985.\n\n\nCode\nlargest_mire = mires_65[mires_65.drain_change_6585 == mires_65.drain_change_6585.max()].geometry.iloc[0]\nfig, axs = plt.subplots(2,2, dpi=200, figsize=(10,10))\nmires_65.clip(largest_mire, keep_geom_type=True).plot(ax=axs[0,0], facecolor='none')\nmires_80s.clip(largest_mire, keep_geom_type=True).plot(ax=axs[0,1], facecolor='none')\nmires_05.clip(largest_mire, keep_geom_type=True).plot(ax=axs[1,0], facecolor='none')\nmires_22.clip(largest_mire, keep_geom_type=True).plot(ax=axs[1,1], facecolor='none')\n\nwatercourses_65.clip(largest_mire, keep_geom_type=True).plot(ax=axs[0,0])\nwatercourses_80s.clip(largest_mire).plot(ax=axs[0,1])\nwatercourses_05.clip(largest_mire).plot(ax=axs[1,0])\nwatercourses_22.clip(largest_mire).plot(ax=axs[1,1])\n\naxs[0,0].set_title(f'Watercourses in 1965, {watercourses_65.clip(largest_mire).length.sum()*10**-3:.2f} km')\naxs[0,1].set_title(f'Watercourses in 1985, {watercourses_80s.clip(largest_mire).length.sum()*10**-3:.2f} km')\naxs[1,0].set_title(f'Watercourses in 2005, {watercourses_05.clip(largest_mire).length.sum()*10**-3:.2f} km')\naxs[1,1].set_title(f'Watercourses in 2022, {watercourses_22.clip(largest_mire).length.sum()*10**-3:.2f} km')\n\nplt.tight_layout()\n\n\n\n\n\nSame area as map patches and aerial images.\n\n\nCode\nfig, axs = plt.subplots(2,2, dpi=200, figsize=(10,10))\nimg = get_map_patch(box(*largest_mire.bounds), 1965, map_path)\nfor a in axs.flatten(): a.axis('off')\naxs[0,0].imshow(img, cmap='gray')\naxs[0,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(box(*largest_mire.bounds), 1985, map_path)\naxs[0,1].imshow(img, cmap='gray')\naxs[0,1].set_title(f'Map patch from 1980s')\n\n\n# WCS only supports 2x2km images so need to get creative\nmidx = (largest_mire.bounds[2] - largest_mire.bounds[0]) / 2\nmidy = (largest_mire.bounds[3] - largest_mire.bounds[1]) / 2\nbotl,_ = get_wcs_img((largest_mire.bounds[0], \n                      largest_mire.bounds[1], \n                      largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[3]-midy), 2005)\nbotr,_ = get_wcs_img((largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[1], \n                      largest_mire.bounds[2], \n                      largest_mire.bounds[3]-midy), 2005)\ntopl,_ = get_wcs_img((largest_mire.bounds[0], \n                      largest_mire.bounds[3]-midy, \n                      largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[3]), 2005)\ntopr,year = get_wcs_img((largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[3]-midy, \n                      largest_mire.bounds[2],\n                      largest_mire.bounds[3]), 2005)\ntoprow = np.hstack((topl, topr))\nbotrow = np.hstack((botl, botr))\nfull = np.vstack((toprow, botrow))\naxs[1,0].imshow(full, cmap='gray')\naxs[1,0].set_title(f'Aerial image from {year}')\n\nbotl,_ = get_wcs_img((largest_mire.bounds[0], \n                      largest_mire.bounds[1], \n                      largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[3]-midy), 2022)\nbotr,_ = get_wcs_img((largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[1], \n                      largest_mire.bounds[2], \n                      largest_mire.bounds[3]-midy), 2022)\ntopl,_ = get_wcs_img((largest_mire.bounds[0], \n                      largest_mire.bounds[3]-midy, \n                      largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[3]), 2022)\ntopr,year = get_wcs_img((largest_mire.bounds[2]-midx, \n                      largest_mire.bounds[3]-midy, \n                      largest_mire.bounds[2],\n                      largest_mire.bounds[3]), 2022)\ntoprow = np.hstack((topl, topr))\nbotrow = np.hstack((botl, botr))\nfull = np.vstack((toprow, botrow))\naxs[1,1].imshow(full, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()"
  },
  {
    "objectID": "change_analysis.html#water-bodies-1",
    "href": "change_analysis.html#water-bodies-1",
    "title": "Change analysis",
    "section": "2.5 Water bodies",
    "text": "2.5 Water bodies\nEven though water bodies don’t change that much, let’s visualize them for completeness.\n\n\nCode\nfor r in results:\n    polygonize(respath/r, polypath/'waterbodies'/r.replace('tif', 'geojson'), target_class=5, scale_factor=1/2)\n\n\n\n\nCode\nwaterbodies_65 = None\nwaterbodies_80s = None\n\nfor p in os.listdir(polypath/'waterbodies'):\n    union_gdf = gpd.read_file(polypath/'waterbodies'/p)\n    if '1965' in p:\n        if waterbodies_65 is None: waterbodies_65 = union_gdf\n        else: waterbodies_65 = pd.concat((waterbodies_65, union_gdf))\n    else:\n        if waterbodies_80s is None: waterbodies_80s = union_gdf\n        else: waterbodies_80s = pd.concat((waterbodies_80s, union_gdf))\nwaterbodies_65 = waterbodies_65.clip(study_area.geometry.iloc[0])\nwaterbodies_80s = waterbodies_80s.clip(study_area.geometry.iloc[0])\nwaterbodies_65.reset_index(inplace=True, drop=True)\nwaterbodies_80s.reset_index(inplace=True, drop=True)\n\nwaterbodies_05 = gpd.read_file(mtk_path/'2005/waterbodies.geojson')\nwaterbodies_22 = gpd.read_file(mtk_path/'2022/jarvet_2022.geojson')\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(10,10), dpi=150)\nwaterbodies_65.plot(ax=axs[0,0], color='tab:blue')\naxs[0,0].set_title(f'Water bodies 1965, total area {waterbodies_65.area.sum() * 10**-6:.2f} km²')\nwaterbodies_80s.plot(ax=axs[0,1], color='tab:blue')\naxs[0,1].set_title(f'Water bodies 1984-1985 {waterbodies_80s.area.sum() * 10**-6:.2f} km²')\nwaterbodies_05.plot(ax=axs[1,0], color='tab:blue')\naxs[1,0].set_title(f'Water bodies 2005 {waterbodies_05.area.sum() * 10**-6:.2f} km²')\nwaterbodies_22.plot(ax=axs[1,1], color='tab:blue')\naxs[1,1].set_title(f'Water bodies 2022 {waterbodies_22.area.sum() * 10**-6:.2f} km²')\nplt.tight_layout()\n\n\n\n\n\nSome changes are due to model classifying wide rivers etc. as water bodies instead of watercourses.\n\n\nCode\ngrid = aggregate_area_to_grid(grid, waterbodies_65, 'waterbody_area_65')\ngrid = aggregate_area_to_grid(grid, waterbodies_80s, 'waterbody_area_85')\ngrid = aggregate_area_to_grid(grid, waterbodies_05, 'waterbody_area_05')\ngrid = aggregate_area_to_grid(grid, waterbodies_22, 'waterbody_area_22')\n\n\n\n\nCode\nfig, axs = plt.subplots(2,2, figsize=(14,10))\ngrid.fillna(0, inplace=True)\ngrid.plot(column='waterbody_area_65', ax=axs[0,0], vmin=0, vmax=.500**2, legend=True).set_title('1965')\ngrid.plot(column='waterbody_area_85', ax=axs[0,1], vmin=0, vmax=.500**2, legend=True).set_title('1984-1985')\ngrid.plot(column='waterbody_area_05', ax=axs[1,0], vmin=0, vmax=.500**2, legend=True).set_title('2005')\ngrid.plot(column='waterbody_area_22', ax=axs[1,1], vmin=0, vmax=.500**2, legend=True).set_title('2022')\nplt.tight_layout()\n\n\n\n\n\nQuantify the change. Negative change means decreased waterbody area.\n\n\nCode\ngrid['waterbody_change_6585'] = (grid.waterbody_area_85 - grid.waterbody_area_65)\ngrid['waterbody_change_8505'] = (grid.waterbody_area_05 - grid.waterbody_area_85)\ngrid['waterbody_change_0522'] = (grid.waterbody_area_22 - grid.waterbody_area_05)\n\n\nChange stats for 1965-1985:\n\n\nCode\nprint(f'Gain: {grid[grid.waterbody_change_6585 > 0].waterbody_change_6585.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.waterbody_change_6585 < 0].waterbody_change_6585.sum():.2f} km²')\nprint(f'Change: {grid.waterbody_change_6585.sum():.2f} km²')\n\n\nGain: 0.97 km²\nLoss: 1.93 km²\nChange: -0.97 km²\n\n\nChange stats for 1985-2005\n\n\nCode\nprint(f'Gain: {grid[grid.waterbody_change_8505 > 0].waterbody_change_8505.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.waterbody_change_8505 < 0].waterbody_change_8505.sum():.2f} km²')\nprint(f'Change: {grid.waterbody_change_8505.sum():.2f} km²')\n\n\nGain: 2.01 km²\nLoss: 0.77 km²\nChange: 1.24 km²\n\n\nChange stats for 2005-2022\n\n\nCode\nprint(f'Gain: {grid[grid.waterbody_change_0522 > 0].waterbody_change_0522.sum():.2f} km²')\nprint(f'Loss: {-grid[grid.waterbody_change_0522 < 0].waterbody_change_0522.sum():.2f} km²')\nprint(f'Change: {grid.waterbody_change_0522.sum():.2f} km²')\n\n\nGain: 0.38 km²\nLoss: 0.18 km²\nChange: 0.20 km²\n\n\n\n\nCode\nfig,axs = plt.subplots(1,4, figsize=(15,5), dpi=200, gridspec_kw={'width_ratios': [1,1,1,0.05]})\n\ngrid.plot(column='waterbody_change_6585', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[0])\ngrid.plot(column='waterbody_change_8505', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[1])\ngrid.plot(column='waterbody_change_0522', cmap='seismic', vmin=-.20, vmax=.20, ax=axs[2])\naxs[0].set_title(f'1965-1985, total change {grid.waterbody_change_6585.sum():.2f} km²')\naxs[1].set_title(f'1985-2005, total change {grid.waterbody_change_8505.sum():.2f} km²')\naxs[2].set_title(f'2005-2022, total change {grid.waterbody_change_0522.sum():.2f} km²')\n\nnorm = colors.Normalize(vmin=-.2,vmax=.2)\nsm = plt.cm.ScalarMappable(cmap='seismic', norm=norm)\nticks = [-.2,-.1,0,.1,.2]\ncbar = plt.colorbar(sm, cax=axs[3], ticks=ticks)\ncbar.ax.set_yticklabels([f'{t} km²' for t in ticks])\nplt.suptitle('Changes in waterbody area, aggregated to 500x500m grid')\nplt.show()\n\n\n\n\n\nVisualize the location where the waterbody area has decreased the most between 1965 and 1985. For 1965 and 1980s show the corresponding map patch along with the data.\nFor 2005 and 2022, show the closest aerial image to that year. Unfortunately the closest historical images available are from 1949 and 1979, so we can’t really use them for visualizations.\n\n\nCode\nwaterbodyloss_6585_cellid = grid[grid.waterbody_change_6585 == grid.waterbody_change_6585.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == waterbodyloss_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nwaterbodies_65.clip(grid[grid.cellid == waterbodyloss_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:blue').set_title('waterbodies in 1965')\ngrid[grid.cellid == waterbodyloss_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nwaterbodies_80s.clip(grid[grid.cellid == waterbodyloss_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:blue').set_title('waterbodies in 1985')\n\nimg = get_map_patch(grid[grid.cellid == waterbodyloss_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == waterbodyloss_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\nSame for 1985 and 2005\n\n\nCode\nwaterbodyloss_8505_cellid = grid[grid.waterbody_change_8505 == grid.waterbody_change_8505.min()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == waterbodyloss_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nwaterbodies_80s.clip(grid[grid.cellid == waterbodyloss_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:blue').set_title('waterbodies in 1985')\ngrid[grid.cellid == waterbodyloss_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nwaterbodies_05.clip(grid[grid.cellid == waterbodyloss_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:blue').set_title('waterbodies in 2005')\n\nimg = get_map_patch(grid[grid.cellid == waterbodyloss_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == waterbodyloss_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()\n\n\n\n\n\nAnd then same visualizations for waterbody area increase.\n\n\nCode\nwaterbodygain_6585_cellid = grid[grid.waterbody_change_6585 == grid.waterbody_change_6585.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == waterbodygain_6585_cellid].plot(ax=axs[0,0], facecolor='none')\nwaterbodies_65.clip(grid[grid.cellid == waterbodygain_6585_cellid].geometry).plot(ax=axs[0,0], color='tab:blue').set_title('waterbodies in 1965')\ngrid[grid.cellid == waterbodygain_6585_cellid].plot(ax=axs[0,1], facecolor='none')\nwaterbodies_80s.clip(grid[grid.cellid == waterbodygain_6585_cellid].geometry).plot(ax=axs[0,1], color='tab:blue').set_title('waterbodies in 1985')\n\nimg = get_map_patch(grid[grid.cellid == waterbodygain_6585_cellid].geometry.iloc[0], 1965, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1965')\n\nimg = get_map_patch(grid[grid.cellid == waterbodygain_6585_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Map patch from 1980s')\nplt.show()\n\n\n\n\n\n\n\nCode\nwaterbodygain_8505_cellid = grid[grid.waterbody_change_8505 == grid.waterbody_change_8505.max()].cellid.iloc[0]\nfig, axs = plt.subplots(2,2, figsize=(10,10))\ngrid[grid.cellid == waterbodygain_8505_cellid].plot(ax=axs[0,0], facecolor='none')\nwaterbodies_80s.clip(grid[grid.cellid == waterbodygain_8505_cellid].geometry).plot(ax=axs[0,0], color='tab:blue').set_title('waterbodies in 1985')\ngrid[grid.cellid == waterbodygain_8505_cellid].plot(ax=axs[0,1], facecolor='none')\nwaterbodies_05.clip(grid[grid.cellid == waterbodygain_8505_cellid].geometry).plot(ax=axs[0,1], color='tab:blue').set_title('waterbodies in 2005')\n\nimg = get_map_patch(grid[grid.cellid == waterbodygain_8505_cellid].geometry.iloc[0], 1985, map_path)\naxs[1,0].imshow(img, cmap='gray')\naxs[1,0].set_title(f'Map patch from 1980s')\n\nimg, year = get_wcs_img(grid[grid.cellid == waterbodygain_8505_cellid].total_bounds, 2005)\naxs[1,1].imshow(img, cmap='gray')\naxs[1,1].set_title(f'Aerial image from {year}')\nplt.show()"
  }
]